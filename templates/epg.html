{% extends "base.html" %}

{% block title %}EPG Sources - IPTV Proxy{% endblock %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pb-2 mb-3 border-bottom">
    <h1 class="h2"><i class="bi bi-calendar-event"></i> EPG Sources</h1>
    <div>
        <button class="btn btn-outline-info me-2" id="refresh-coverage-btn">
            <i class="bi bi-bar-chart"></i> View Coverage
        </button>
        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#sourceModal" id="add-source-btn">
            <i class="bi bi-plus-circle"></i> Add EPG Source
        </button>
    </div>
</div>

<!-- Coverage Summary -->
<div id="coverage-summary" class="row mb-4" style="display: none;">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span><i class="bi bi-bar-chart-fill"></i> EPG Coverage Summary</span>
                <button type="button" class="btn-close" onclick="document.getElementById('coverage-summary').style.display='none'"></button>
            </div>
            <div class="card-body" id="coverage-content">
                <div class="text-center">
                    <div class="spinner-border" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Nav Tabs -->
<ul class="nav nav-tabs mb-4" id="epgTabs" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="sources-tab" data-bs-toggle="tab" data-bs-target="#sources-pane" type="button">
            <i class="bi bi-database"></i> EPG Sources
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="channels-tab" data-bs-toggle="tab" data-bs-target="#channels-pane" type="button">
            <i class="bi bi-list"></i> EPG Channels
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="mappings-tab" data-bs-toggle="tab" data-bs-target="#mappings-pane" type="button">
            <i class="bi bi-link-45deg"></i> Channel Mappings
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="sd-tab" data-bs-toggle="tab" data-bs-target="#sd-pane" type="button">
            <i class="bi bi-broadcast-pin"></i> Schedules Direct
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="xmltv-tab" data-bs-toggle="tab" data-bs-target="#xmltv-pane" type="button">
            <i class="bi bi-terminal"></i> XMLTV Grabbers
        </button>
    </li>
</ul>

<div class="tab-content" id="epgTabContent">
    <!-- EPG Sources Tab -->
    <div class="tab-pane fade show active" id="sources-pane" role="tabpanel">
        <div id="sources-list">
            <div class="text-center">
                <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- EPG Channels Tab -->
    <div class="tab-pane fade" id="channels-pane" role="tabpanel">
        <div class="row mb-3">
            <div class="col-md-4">
                <label for="channelSourceSelect" class="form-label">Filter by Source:</label>
                <select class="form-select" id="channelSourceSelect">
                    <option value="">All Sources</option>
                </select>
            </div>
            <div class="col-md-4">
                <label for="channelSearch" class="form-label">Search:</label>
                <input type="text" class="form-control" id="channelSearch" placeholder="Search channels...">
            </div>
        </div>
        <div id="channels-list">
            <div class="text-center text-muted py-4">
                Select a source or search to view EPG channels
            </div>
        </div>
    </div>

    <!-- Channel Mappings Tab -->
    <div class="tab-pane fade" id="mappings-pane" role="tabpanel">
        <div class="row mb-3">
            <div class="col-md-3">
                <label for="mappingAccountSelect" class="form-label">Filter by Account:</label>
                <select class="form-select" id="mappingAccountSelect">
                    <option value="">All Accounts</option>
                </select>
            </div>
            <div class="col-md-3">
                <label for="mappingCategorySelect" class="form-label">Filter by Category:</label>
                <select class="form-select" id="mappingCategorySelect">
                    <option value="">All Categories</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="mappingViewSelect" class="form-label">Show:</label>
                <select class="form-select" id="mappingViewSelect">
                    <option value="all">All Channels</option>
                    <option value="unmapped">Unmapped Only</option>
                    <option value="mapped">Mapped Only</option>
                </select>
            </div>
            <div class="col-md-2">
                <div class="form-check mt-4">
                    <input class="form-check-input" type="checkbox" id="showFilteredChannels">
                    <label class="form-check-label" for="showFilteredChannels">
                        Include filtered-out
                    </label>
                </div>
            </div>
            <div class="col-md-2 text-end">
                <button class="btn btn-success mt-3" id="auto-match-btn" disabled>
                    <i class="bi bi-magic"></i> Auto-Match
                </button>
            </div>
        </div>
        <!-- Skip Threshold Slider -->
        <div class="row mb-3" id="skip-threshold-row" style="display: none;">
            <div class="col-md-6">
                <label for="skipThresholdSlider" class="form-label">Skip Threshold: <span id="skipThresholdValue">85%</span></label>
                <input type="range" class="form-range" id="skipThresholdSlider" min="0" max="100" value="85">
                <div class="d-flex justify-content-between small text-muted">
                    <span>Re-match all (0%)</span>
                    <span>Skip good matches (100%)</span>
                </div>
            </div>
            <div class="col-md-6">
                <small class="text-muted d-block mt-2">
                    Channels with existing matches at or above this confidence level will be skipped during auto-match.
                </small>
            </div>
        </div>
        <!-- Auto-Match Results Alert -->
        <div id="autoMatchResultsAlert" class="alert alert-dismissible fade show d-none" role="alert">
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            <div id="autoMatchResultsContent"></div>
        </div>
        <div id="mappings-list">
            <div class="text-center text-muted py-4">
                Select an account to view channel mappings
            </div>
        </div>
    </div>

    <!-- Schedules Direct Tab -->
    <div class="tab-pane fade" id="sd-pane" role="tabpanel">
        <div class="row">
            <div class="col-md-8">
                <!-- SD Status -->
                <div class="card mb-4">
                    <div class="card-header">
                        <i class="bi bi-broadcast-pin"></i> Schedules Direct Service Status
                    </div>
                    <div class="card-body" id="sd-status-content">
                        <div class="text-center">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- SD Lineups -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span><i class="bi bi-list-ul"></i> SD Lineups</span>
                        <button class="btn btn-sm btn-outline-primary" id="searchLineupsModalBtn" data-bs-toggle="modal" data-bs-target="#searchLineupModal" disabled title="Select a Schedules Direct source first">
                            <i class="bi bi-search"></i> Search Lineups
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="sdSourceSelect" class="form-label">Select SD Source:</label>
                            <select class="form-select" id="sdSourceSelect">
                                <option value="">-- Select a Schedules Direct source --</option>
                            </select>
                            <div class="form-text text-muted">Select a source to enable Search Lineups</div>
                        </div>
                        <div id="sd-lineups-list">
                            <div class="text-center text-muted py-3">
                                Select a Schedules Direct source to view lineups
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card bg-light">
                    <div class="card-header">
                        <i class="bi bi-info-circle"></i> About Schedules Direct
                    </div>
                    <div class="card-body">
                        <p class="small">
                            <a href="https://schedulesdirect.org/" target="_blank">Schedules Direct</a> is a 
                            non-profit service providing North American TV listings data.
                        </p>
                        <p class="small">
                            To use SD, create an EPG source of type "Schedules Direct" and enter your credentials.
                        </p>
                        <ul class="small">
                            <li>Add lineups for your area</li>
                            <li>Sync station data</li>
                            <li>Match stations to your channels</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- XMLTV Grabbers Tab -->
    <div class="tab-pane fade" id="xmltv-pane" role="tabpanel">
        <div class="row">
            <div class="col-md-8">
                <!-- Installed Grabbers -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span><i class="bi bi-terminal"></i> Installed XMLTV Grabbers</span>
                        <button class="btn btn-sm btn-outline-primary" onclick="loadXmltvGrabbers()">
                            <i class="bi bi-arrow-repeat"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body" id="xmltv-grabbers-list">
                        <div class="text-center">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Grabber Configurations -->
                <div class="card mb-4">
                    <div class="card-header">
                        <i class="bi bi-gear"></i> Grabber Configurations
                    </div>
                    <div class="card-body" id="xmltv-configs-list">
                        <div class="text-center text-muted py-3">
                            Configurations will appear here after grabbers are loaded
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card bg-light">
                    <div class="card-header">
                        <i class="bi bi-info-circle"></i> About XMLTV Grabbers
                    </div>
                    <div class="card-body">
                        <p class="small">
                            <a href="https://xmltv.org/" target="_blank">XMLTV</a> provides grabber tools
                            (tv_grab_*) to fetch EPG data from various regional sources.
                        </p>
                        <p class="small">
                            Available grabbers depend on the Docker image. Common grabbers include:
                        </p>
                        <ul class="small">
                            <li><code>tv_grab_zz_sdjson</code> - Schedules Direct</li>
                            <li><code>tv_grab_na_dd</code> - DataDirect (NA)</li>
                            <li><code>tv_grab_uk_tvguide</code> - UK TV Guide</li>
                            <li>And many more region-specific grabbers</li>
                        </ul>
                        <p class="small">
                            To use a grabber:
                        </p>
                        <ol class="small">
                            <li>Configure the grabber (credentials, region, etc.)</li>
                            <li>Create an EPG source of type "XMLTV Grabber"</li>
                            <li>Select the grabber and configuration</li>
                            <li>Sync to fetch EPG data</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add/Edit EPG Source Modal -->
<div class="modal fade" id="sourceModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="sourceModalLabel">Add EPG Source</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="sourceForm">
                    <input type="hidden" id="sourceId">
                    <div class="mb-3">
                        <label for="sourceName" class="form-label">Name *</label>
                        <input type="text" class="form-control" id="sourceName" required>
                    </div>
                    <div class="mb-3">
                        <label for="sourceType" class="form-label">Source Type *</label>
                        <select class="form-select" id="sourceType" required>
                            <option value="">Select a type...</option>
                            <option value="provider">IPTV Provider (from account)</option>
                            <option value="xmltv_url">External XMLTV URL</option>
                            <option value="schedules_direct">Schedules Direct</option>
                            <option value="xmltv_grabber">XMLTV Grabber (tv_grab_*)</option>
                        </select>
                    </div>

                    <!-- Provider-specific fields -->
                    <div id="providerFields" style="display: none;">
                        <div class="mb-3">
                            <label for="sourceAccountId" class="form-label">Account *</label>
                            <select class="form-select" id="sourceAccountId">
                                <option value="">Select an account...</option>
                            </select>
                            <div class="form-text">Select the IPTV account to pull EPG data from</div>
                        </div>
                    </div>

                    <!-- XMLTV URL fields -->
                    <div id="xmltvFields" style="display: none;">
                        <div class="mb-3">
                            <label for="sourceUrl" class="form-label">XMLTV URL *</label>
                            <input type="url" class="form-control" id="sourceUrl" placeholder="https://example.com/epg.xml">
                            <div class="form-text">URL to the XMLTV file</div>
                        </div>
                    </div>

                    <!-- Schedules Direct fields -->
                    <div id="sdFields" style="display: none;">
                        <div class="mb-3">
                            <label for="sdUsername" class="form-label">SD Username *</label>
                            <input type="text" class="form-control" id="sdUsername">
                        </div>
                        <div class="mb-3">
                            <label for="sdPassword" class="form-label">SD Password *</label>
                            <input type="password" class="form-control" id="sdPassword">
                        </div>
                        <button type="button" class="btn btn-outline-secondary btn-sm mb-3" id="testSdCredentialsBtn">
                            <i class="bi bi-check-circle"></i> Test Credentials
                        </button>
                        <div id="sdCredentialsResult" class="mb-3" style="display: none;"></div>
                    </div>

                    <!-- XMLTV Grabber fields -->
                    <div id="grabberFields" style="display: none;">
                        <div class="mb-3">
                            <label for="grabberSelect" class="form-label">Grabber *</label>
                            <select class="form-select" id="grabberSelect">
                                <option value="">Select a grabber...</option>
                            </select>
                            <div class="form-text">Select an installed XMLTV grabber</div>
                        </div>
                        <div class="mb-3">
                            <label for="grabberConfigName" class="form-label">Configuration Name</label>
                            <input type="text" class="form-control" id="grabberConfigName" placeholder="my-config">
                            <div class="form-text">Optional: Name of a saved configuration</div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="grabberDays" class="form-label">Days to Fetch</label>
                                    <input type="number" class="form-control" id="grabberDays" value="7" min="1" max="14">
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="grabberOffset" class="form-label">Day Offset</label>
                                    <input type="number" class="form-control" id="grabberOffset" value="0" min="0" max="14">
                                </div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-outline-secondary btn-sm mb-3" id="testGrabberBtn">
                            <i class="bi bi-check-circle"></i> Test Grabber
                        </button>
                        <div id="grabberTestResult" class="mb-3" style="display: none;"></div>
                    </div>

                    <div class="mb-3">
                        <label for="sourcePriority" class="form-label">Priority</label>
                        <input type="number" class="form-control" id="sourcePriority" value="100" min="1" max="1000">
                        <div class="form-text">Lower numbers = higher priority when merging EPG data</div>
                    </div>
                    <div class="mb-3 form-check">
                        <input type="checkbox" class="form-check-input" id="sourceEnabled" checked>
                        <label class="form-check-label" for="sourceEnabled">Enabled</label>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="save-source-btn">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Search Lineups Modal -->
<div class="modal fade" id="searchLineupModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Search SD Lineups</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row mb-3">
                    <div class="col-md-4">
                        <label for="searchCountry" class="form-label">Country</label>
                        <select class="form-select" id="searchCountry">
                            <option value="USA">USA</option>
                            <option value="CAN">Canada</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="searchPostalCode" class="form-label">Postal/ZIP Code</label>
                        <input type="text" class="form-control" id="searchPostalCode" placeholder="12345">
                    </div>
                    <div class="col-md-4 d-flex align-items-end">
                        <button type="button" class="btn btn-primary w-100" id="searchLineupsBtn">
                            <i class="bi bi-search"></i> Search
                        </button>
                    </div>
                </div>
                <div id="lineupSearchResults">
                    <div class="text-center text-muted py-3">
                        Enter a postal code to search for available lineups
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Manual Mapping Modal -->
<div class="modal fade" id="manualMappingModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Create Manual Mapping</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label">Channel</label>
                    <div id="manualMappingChannel" class="form-control-plaintext"></div>
                    <input type="hidden" id="manualMappingChannelId">
                </div>
                <div class="mb-3">
                    <label for="manualMappingEpgChannel" class="form-label">EPG Channel *</label>
                    <input type="text" class="form-control" id="manualMappingEpgSearch" placeholder="Search EPG channels...">
                    <select class="form-select mt-2" id="manualMappingEpgChannel" size="6">
                        <option value="">Search for EPG channels above...</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveManualMappingBtn">Create Mapping</button>
            </div>
        </div>
    </div>
</div>

<!-- SD Stations Modal -->
<div class="modal fade" id="sdStationsModal" tabindex="-1">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="sdStationsModalTitle">Lineup Stations</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <input type="text" class="form-control" id="stationSearch" placeholder="Search stations...">
                </div>
                <div id="sd-stations-list" style="max-height: 400px; overflow-y: auto;">
                    <div class="text-center">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let sources = [];
let accounts = [];
const sourceModal = new bootstrap.Modal(document.getElementById('sourceModal'));
const searchLineupModal = new bootstrap.Modal(document.getElementById('searchLineupModal'));
const manualMappingModal = new bootstrap.Modal(document.getElementById('manualMappingModal'));
const sdStationsModal = new bootstrap.Modal(document.getElementById('sdStationsModal'));

// ============================================================================
// Initialization
// ============================================================================

document.addEventListener('DOMContentLoaded', async () => {
    await loadAccounts();
    await loadSources();
    loadSdStatus();
    
    // Set up event listeners
    document.getElementById('sourceType').addEventListener('change', onSourceTypeChange);
    document.getElementById('save-source-btn').addEventListener('click', saveSource);
    document.getElementById('testSdCredentialsBtn').addEventListener('click', testSdCredentials);
    document.getElementById('testGrabberBtn').addEventListener('click', testGrabber);
    document.getElementById('refresh-coverage-btn').addEventListener('click', loadCoverage);
    document.getElementById('add-source-btn').addEventListener('click', () => {
        document.getElementById('sourceId').value = '';
        document.getElementById('sourceForm').reset();
        document.getElementById('sourceModalLabel').textContent = 'Add EPG Source';
        onSourceTypeChange();
    });
    
    // Channels tab
    document.getElementById('channelSourceSelect').addEventListener('change', loadEpgChannels);
    document.getElementById('channelSearch').addEventListener('input', debounce(loadEpgChannels, 300));
    
    // Mappings tab
    document.getElementById('mappingAccountSelect').addEventListener('change', async (e) => {
        await loadCategoriesForAccount(e.target.value);
        document.getElementById('mappingCategorySelect').value = '';
        updateAutoMatchButton();
        loadMappings();
    });
    document.getElementById('mappingCategorySelect').addEventListener('change', loadMappings);
    document.getElementById('mappingViewSelect').addEventListener('change', loadMappings);
    document.getElementById('showFilteredChannels').addEventListener('change', loadMappings);
    document.getElementById('auto-match-btn').addEventListener('click', runAutoMatch);
    
    // Skip threshold slider
    document.getElementById('skipThresholdSlider').addEventListener('input', (e) => {
        document.getElementById('skipThresholdValue').textContent = e.target.value + '%';
    });
    
    // Infinite scroll for mappings
    const mappingsList = document.getElementById('mappings-list');
    mappingsList.addEventListener('scroll', () => {
        if (mappingsState.hasMore && !mappingsState.loading) {
            const scrollHeight = mappingsList.scrollHeight;
            const scrollTop = mappingsList.scrollTop;
            const clientHeight = mappingsList.clientHeight;
            
            if (scrollTop + clientHeight >= scrollHeight - 100) {
                loadMoreMappings();
            }
        }
    });
    
    // SD tab
    document.getElementById('sdSourceSelect').addEventListener('change', loadSdLineups);
    document.getElementById('searchLineupsBtn').addEventListener('click', searchLineups);
    
    // Manual mapping
    document.getElementById('manualMappingEpgSearch').addEventListener('input', debounce(searchEpgChannels, 300));
    document.getElementById('saveManualMappingBtn').addEventListener('click', saveManualMapping);
    
    // SD stations search
    document.getElementById('stationSearch').addEventListener('input', debounce(filterStations, 200));
    
    // Tab change handlers
    document.getElementById('channels-tab').addEventListener('shown.bs.tab', loadEpgChannels);
    document.getElementById('mappings-tab').addEventListener('shown.bs.tab', loadMappings);
    document.getElementById('sd-tab').addEventListener('shown.bs.tab', () => {
        loadSdStatus();
        populateSdSourceSelect();
    });
    document.getElementById('xmltv-tab').addEventListener('shown.bs.tab', () => {
        loadXmltvGrabbers();
        loadXmltvConfigs();
    });
});

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// ============================================================================
// Load Data Functions
// ============================================================================

async function loadAccounts() {
    try {
        const response = await fetch('/api/accounts');
        const data = await response.json();
        
        // Check if we got an error response instead of an array
        if (!response.ok || !Array.isArray(data)) {
            console.error('Error loading accounts:', data.error || 'Invalid response');
            return;
        }
        
        accounts = data;
        
        // Populate account selects
        const selects = ['sourceAccountId', 'mappingAccountSelect', 'matchAccountSelect'];
        selects.forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                const firstOption = select.options[0].outerHTML;
                select.innerHTML = firstOption;
                accounts.forEach(a => {
                    select.innerHTML += `<option value="${a.id}">${a.name}</option>`;
                });
            }
        });
    } catch (error) {
        console.error('Error loading accounts:', error);
    }
}

async function loadSources() {
    try {
        const response = await fetch('/api/epg/sources');
        const data = await response.json();
        
        // Check if we got an error response instead of an array
        if (!response.ok || !Array.isArray(data)) {
            throw new Error(data.error || 'Invalid response from server');
        }
        
        sources = data;
        renderSources();
        populateSourceSelects();
    } catch (error) {
        document.getElementById('sources-list').innerHTML = `
            <div class="alert alert-danger">Error loading EPG sources: ${error.message}</div>
        `;
    }
}

function populateSourceSelects() {
    const selects = ['channelSourceSelect', 'matchSourceSelect'];
    selects.forEach(id => {
        const select = document.getElementById(id);
        if (select) {
            const firstOption = select.options[0].outerHTML;
            select.innerHTML = firstOption;
            sources.forEach(s => {
                select.innerHTML += `<option value="${s.id}">${s.name} (${s.source_type})</option>`;
            });
        }
    });
}

function populateSdSourceSelect() {
    const select = document.getElementById('sdSourceSelect');
    const firstOption = select.options[0].outerHTML;
    select.innerHTML = firstOption;
    sources.filter(s => s.source_type === 'schedules_direct').forEach(s => {
        select.innerHTML += `<option value="${s.id}">${s.name}</option>`;
    });
}

function renderSources() {
    const container = document.getElementById('sources-list');
    
    if (sources.length === 0) {
        container.innerHTML = `
            <div class="alert alert-info">
                <i class="bi bi-info-circle"></i> No EPG sources configured yet.
                Click "Add EPG Source" to get started.
            </div>
        `;
        return;
    }
    
    let html = '<div class="table-responsive"><table class="table table-striped">';
    html += `
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Source</th>
                <th>Channels</th>
                <th>Last Sync</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
    `;
    
    for (const source of sources) {
        const statusBadge = source.last_sync_status === 'success' 
            ? '<span class="badge bg-success">Success</span>'
            : source.last_sync_status === 'error'
            ? '<span class="badge bg-danger">Error</span>'
            : '<span class="badge bg-secondary">Never synced</span>';
            
        const sourceInfo = source.source_type === 'provider' 
            ? (source.account_name || 'Account ' + source.account_id)
            : source.source_type === 'xmltv_url'
            ? '<small class="text-muted">' + (source.url?.substring(0, 40) || 'No URL') + '...</small>'
            : source.source_type === 'schedules_direct'
            ? '<i class="bi bi-broadcast-pin"></i> SD'
            : source.source_type === 'xmltv_grabber'
            ? '<i class="bi bi-terminal"></i> ' + (source.xmltv_grabber || 'Grabber')
            : '-';
            
        html += `
            <tr>
                <td>
                    ${source.name}
                    ${!source.enabled ? '<span class="badge bg-secondary ms-2">Disabled</span>' : ''}
                </td>
                <td><span class="badge bg-info">${source.source_type}</span></td>
                <td>${sourceInfo}</td>
                <td>${source.channel_count || 0}</td>
                <td>${source.last_sync ? new Date(source.last_sync).toLocaleString() : 'Never'}</td>
                <td>${statusBadge}</td>
                <td>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-primary" onclick="syncSource(${source.id})" title="Sync">
                            <i class="bi bi-arrow-repeat"></i>
                        </button>
                        <button class="btn btn-outline-secondary" onclick="editSource(${source.id})" title="Edit">
                            <i class="bi bi-pencil"></i>
                        </button>
                        <button class="btn btn-outline-danger" onclick="deleteSource(${source.id})" title="Delete">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }
    
    html += '</tbody></table></div>';
    container.innerHTML = html;
}

// ============================================================================
// Source CRUD Operations
// ============================================================================

function onSourceTypeChange() {
    const type = document.getElementById('sourceType').value;
    document.getElementById('providerFields').style.display = type === 'provider' ? 'block' : 'none';
    document.getElementById('xmltvFields').style.display = type === 'xmltv_url' ? 'block' : 'none';
    document.getElementById('sdFields').style.display = type === 'schedules_direct' ? 'block' : 'none';
    document.getElementById('grabberFields').style.display = type === 'xmltv_grabber' ? 'block' : 'none';
    
    // Load grabbers list if selecting xmltv_grabber
    if (type === 'xmltv_grabber') {
        populateGrabberSelect();
    }
}

async function saveSource() {
    const id = document.getElementById('sourceId').value;
    const data = {
        name: document.getElementById('sourceName').value,
        source_type: document.getElementById('sourceType').value,
        priority: parseInt(document.getElementById('sourcePriority').value) || 100,
        enabled: document.getElementById('sourceEnabled').checked
    };
    
    // Add type-specific fields
    if (data.source_type === 'provider') {
        data.account_id = parseInt(document.getElementById('sourceAccountId').value);
        if (!data.account_id) {
            alert('Please select an account');
            return;
        }
    } else if (data.source_type === 'xmltv_url') {
        data.url = document.getElementById('sourceUrl').value;
        if (!data.url) {
            alert('Please enter a URL');
            return;
        }
    } else if (data.source_type === 'schedules_direct') {
        data.sd_username = document.getElementById('sdUsername').value;
        data.sd_password = document.getElementById('sdPassword').value;
        if (!data.sd_username || !data.sd_password) {
            alert('Please enter SD credentials');
            return;
        }
    } else if (data.source_type === 'xmltv_grabber') {
        data.xmltv_grabber = document.getElementById('grabberSelect').value;
        data.xmltv_config_name = document.getElementById('grabberConfigName').value || null;
        data.xmltv_days = parseInt(document.getElementById('grabberDays').value) || 7;
        data.xmltv_offset = parseInt(document.getElementById('grabberOffset').value) || 0;
        if (!data.xmltv_grabber) {
            alert('Please select a grabber');
            return;
        }
    }
    
    try {
        const url = id ? `/api/epg/sources/${id}` : '/api/epg/sources';
        const method = id ? 'PUT' : 'POST';
        
        const response = await fetch(url, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            sourceModal.hide();
            await loadSources();
            alert('✓ EPG source saved successfully');
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to save source'));
        }
    } catch (error) {
        alert('Error saving source: ' + error.message);
    }
}

function editSource(id) {
    const source = sources.find(s => s.id === id);
    if (!source) return;
    
    document.getElementById('sourceId').value = source.id;
    document.getElementById('sourceName').value = source.name;
    document.getElementById('sourceType').value = source.source_type;
    document.getElementById('sourcePriority').value = source.priority;
    document.getElementById('sourceEnabled').checked = source.enabled;
    
    if (source.source_type === 'provider') {
        document.getElementById('sourceAccountId').value = source.account_id || '';
    } else if (source.source_type === 'xmltv_url') {
        document.getElementById('sourceUrl').value = source.url || '';
    } else if (source.source_type === 'xmltv_grabber') {
        populateGrabberSelect().then(() => {
            document.getElementById('grabberSelect').value = source.xmltv_grabber || '';
            document.getElementById('grabberConfigName').value = source.xmltv_config_name || '';
            document.getElementById('grabberDays').value = source.xmltv_days || 7;
            document.getElementById('grabberOffset').value = source.xmltv_offset || 0;
        });
    }
    // Note: SD credentials are not pre-filled for security
    
    onSourceTypeChange();
    document.getElementById('sourceModalLabel').textContent = 'Edit EPG Source';
    sourceModal.show();
}

async function deleteSource(id) {
    if (!confirm('Delete this EPG source? This will also delete all its channels.')) return;
    
    try {
        const response = await fetch(`/api/epg/sources/${id}`, { method: 'DELETE' });
        if (response.ok) {
            await loadSources();
            alert('✓ EPG source deleted');
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to delete source'));
        }
    } catch (error) {
        alert('Error deleting source: ' + error.message);
    }
}

async function syncSource(id) {
    const btn = event.target.closest('button');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span>';
    
    try {
        const response = await fetch(`/api/epg/sources/${id}/sync`, { method: 'POST' });
        const result = await response.json();
        
        if (response.ok) {
            await loadSources();
            alert(`✓ Synced! ${result.message}`);
        } else {
            alert('Error: ' + (result.error || 'Sync failed'));
        }
    } catch (error) {
        alert('Error syncing: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

// ============================================================================
// EPG Channels
// ============================================================================

// State for EPG channels lazy loading
let epgChannelsState = {
    offset: 0,
    total: 0,
    limit: 100,
    loading: false,
    sourceId: '',
    search: ''
};

async function loadEpgChannels() {
    const sourceId = document.getElementById('channelSourceSelect').value;
    const search = document.getElementById('channelSearch').value;
    const container = document.getElementById('channels-list');
    
    // Reset state for new query
    epgChannelsState = {
        offset: 0,
        total: 0,
        limit: 100,
        loading: false,
        sourceId: sourceId,
        search: search
    };
    
    if (!sourceId && !search) {
        container.innerHTML = '<div class="text-center text-muted py-4">Select a source or search to view EPG channels</div>';
        return;
    }
    
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        let url = `/api/epg/channels?limit=${epgChannelsState.limit}&offset=0`;
        if (sourceId) url += `&source_id=${sourceId}`;
        if (search) url += `&search=${encodeURIComponent(search)}`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.channels.length === 0) {
            container.innerHTML = '<div class="alert alert-info">No EPG channels found</div>';
            return;
        }
        
        epgChannelsState.total = data.total;
        epgChannelsState.offset = data.channels.length;
        
        let html = `<p class="text-muted mb-2" id="epg-channels-count">Showing ${data.channels.length} of ${data.total} channels</p>`;
        html += '<div class="table-responsive" id="epg-channels-table-container" style="max-height: 600px; overflow-y: auto;">';
        html += '<table class="table table-striped table-sm">';
        html += `
            <thead style="position: sticky; top: 0; background: white; z-index: 1;">
                <tr>
                    <th>Channel ID</th>
                    <th>Display Name</th>
                    <th>Icon</th>
                    <th>Programs</th>
                    <th>Mappings</th>
                </tr>
            </thead>
            <tbody id="epg-channels-tbody">
        `;
        
        for (const ch of data.channels) {
            html += renderEpgChannelRow(ch);
        }
        
        html += '</tbody></table>';
        
        // Add loading indicator at bottom
        if (epgChannelsState.offset < epgChannelsState.total) {
            html += '<div id="epg-channels-loader" class="text-center py-3"><div class="spinner-border spinner-border-sm" role="status"></div> Loading more...</div>';
        }
        
        html += '</div>';
        container.innerHTML = html;
        
        // Set up scroll listener for lazy loading
        const tableContainer = document.getElementById('epg-channels-table-container');
        tableContainer.addEventListener('scroll', handleEpgChannelsScroll);
        
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

function renderEpgChannelRow(ch) {
    return `
        <tr>
            <td><code>${ch.channel_id}</code></td>
            <td>${ch.display_name || '-'}</td>
            <td>${ch.icon_url ? `<img src="${ch.icon_url}" style="max-height: 24px;">` : '-'}</td>
            <td>${ch.program_count || 0}</td>
            <td>${ch.mapping_count || 0}</td>
        </tr>
    `;
}

async function handleEpgChannelsScroll(event) {
    const container = event.target;
    const scrollBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
    
    // Load more when within 100px of bottom
    if (scrollBottom < 100 && !epgChannelsState.loading && epgChannelsState.offset < epgChannelsState.total) {
        await loadMoreEpgChannels();
    }
}

async function loadMoreEpgChannels() {
    if (epgChannelsState.loading || epgChannelsState.offset >= epgChannelsState.total) {
        return;
    }
    
    epgChannelsState.loading = true;
    const loader = document.getElementById('epg-channels-loader');
    if (loader) loader.style.display = 'block';
    
    try {
        let url = `/api/epg/channels?limit=${epgChannelsState.limit}&offset=${epgChannelsState.offset}`;
        if (epgChannelsState.sourceId) url += `&source_id=${epgChannelsState.sourceId}`;
        if (epgChannelsState.search) url += `&search=${encodeURIComponent(epgChannelsState.search)}`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.channels.length > 0) {
            const tbody = document.getElementById('epg-channels-tbody');
            let html = '';
            for (const ch of data.channels) {
                html += renderEpgChannelRow(ch);
            }
            tbody.insertAdjacentHTML('beforeend', html);
            
            epgChannelsState.offset += data.channels.length;
            
            // Update count display
            const countEl = document.getElementById('epg-channels-count');
            if (countEl) {
                countEl.textContent = `Showing ${epgChannelsState.offset} of ${epgChannelsState.total} channels`;
            }
        }
        
        // Hide loader if no more data
        if (epgChannelsState.offset >= epgChannelsState.total && loader) {
            loader.style.display = 'none';
        }
        
    } catch (error) {
        console.error('Error loading more EPG channels:', error);
    } finally {
        epgChannelsState.loading = false;
    }
}

// ============================================================================
// Channel Mappings
// ============================================================================

// State for mappings pagination
const mappingsState = {
    offset: 0,
    limit: 100,
    total: 0,
    loading: false,
    hasMore: false,
    accountId: null,
    categoryId: null,
    viewMode: 'all',  // 'all', 'unmapped', 'mapped'
    showFiltered: false
};

// Update auto-match button state based on account selection
function updateAutoMatchButton() {
    const accountId = document.getElementById('mappingAccountSelect').value;
    const btn = document.getElementById('auto-match-btn');
    const thresholdRow = document.getElementById('skip-threshold-row');
    
    if (accountId) {
        btn.disabled = false;
        thresholdRow.style.display = 'flex';
    } else {
        btn.disabled = true;
        thresholdRow.style.display = 'none';
    }
}

async function loadCategoriesForAccount(accountId) {
    const categorySelect = document.getElementById('mappingCategorySelect');
    categorySelect.innerHTML = '<option value="">All Categories</option>';
    
    if (!accountId) {
        return;
    }
    
    try {
        const response = await fetch(`/api/categories?account_id=${accountId}&include_empty=false`);
        const categories = await response.json();
        
        for (const cat of categories) {
            const opt = document.createElement('option');
            opt.value = cat.id;
            opt.textContent = `${cat.category_name} (${cat.visible_count} channels)`;
            categorySelect.appendChild(opt);
        }
    } catch (error) {
        console.error('Error loading categories:', error);
    }
}

async function loadMappings(reset = true) {
    const accountId = document.getElementById('mappingAccountSelect').value;
    const categoryId = document.getElementById('mappingCategorySelect').value;
    const viewMode = document.getElementById('mappingViewSelect').value;
    const showFiltered = document.getElementById('showFilteredChannels').checked;
    const container = document.getElementById('mappings-list');
    
    // Update auto-match button state
    updateAutoMatchButton();
    
    if (!accountId) {
        container.innerHTML = '<div class="text-center text-muted py-4">Select an account to view channel mappings</div>';
        document.getElementById('mappingCategorySelect').innerHTML = '<option value="">All Categories</option>';
        return;
    }
    
    // Reset state if filters changed or explicit reset
    if (reset || accountId !== mappingsState.accountId || 
        categoryId !== mappingsState.categoryId ||
        viewMode !== mappingsState.viewMode ||
        showFiltered !== mappingsState.showFiltered) {
        mappingsState.offset = 0;
        mappingsState.accountId = accountId;
        mappingsState.categoryId = categoryId;
        mappingsState.viewMode = viewMode;
        mappingsState.showFiltered = showFiltered;
        container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    }
    
    if (mappingsState.loading) return;
    mappingsState.loading = true;
    
    try {
        let url = `/api/epg/mappings?account_id=${accountId}&view_mode=${viewMode}&show_filtered=${showFiltered}&limit=${mappingsState.limit}&offset=${mappingsState.offset}`;
        if (categoryId) {
            url += `&category_id=${categoryId}`;
        }
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
        }
        
        mappingsState.total = data.total;
        mappingsState.hasMore = data.has_more || false;
        
        // Handle empty state
        if (mappingsState.offset === 0 && data.total === 0) {
            let message = 'No channels found with current filters.';
            if (viewMode === 'unmapped') {
                message = '<i class="bi bi-check-circle"></i> All channels have EPG mappings!';
                container.innerHTML = `<div class="alert alert-success">${message}</div>`;
            } else if (viewMode === 'mapped') {
                message = 'No channel mappings found. Run auto-match or create manual mappings.';
                container.innerHTML = `<div class="alert alert-info">${message}</div>`;
            } else {
                container.innerHTML = `<div class="alert alert-info">${message}</div>`;
            }
            return;
        }
        
        // Build table header
        let html = '';
        if (mappingsState.offset === 0) {
            const labelMap = { all: 'channels', unmapped: 'unmapped channels', mapped: 'mapped channels' };
            const filterNote = !showFiltered ? ' (filtered-out channels hidden)' : '';
            html = `<p class="text-muted mb-2" id="mappings-count">Showing 0 of ${data.total} ${labelMap[viewMode] || 'channels'}${filterNote}</p>`;
            html += '<div class="table-responsive" id="mappings-table-container" style="max-height: 600px; overflow-y: auto;">';
            html += '<table class="table table-striped table-sm" id="mappings-table">';
            html += `
                <thead style="position: sticky; top: 0; background: white; z-index: 1;">
                    <tr>
                        <th style="width: 30%">Channel Name</th>
                        <th style="width: 15%">Category</th>
                        <th style="width: 25%">EPG Mapping</th>
                        <th style="width: 15%">Match Info</th>
                        <th style="width: 15%">Actions</th>
                    </tr>
                </thead>
                <tbody id="mappings-tbody">
            `;
        }
        
        // Render rows based on view mode
        const items = data.channels || data.unmapped_channels || data.mappings || [];
        
        for (const item of items) {
            html += renderMappingRow(item, viewMode);
        }
        
        if (mappingsState.offset === 0) {
            html += '</tbody></table>';
            if (data.has_more) {
                html += '<div id="mappings-loader" class="text-center py-3"><div class="spinner-border spinner-border-sm"></div> Loading more...</div>';
            }
            html += '</div>';
            container.innerHTML = html;
            
            // Set up scroll listener for lazy loading
            const tableContainer = document.getElementById('mappings-table-container');
            if (tableContainer) {
                tableContainer.addEventListener('scroll', handleMappingsScroll);
            }
        } else {
            document.getElementById('mappings-tbody').insertAdjacentHTML('beforeend', html);
        }
        
        // Update offset for next load
        mappingsState.offset += items.length;
        
        // Update count display
        const countEl = document.getElementById('mappings-count');
        if (countEl) {
            const labelMap = { all: 'channels', unmapped: 'unmapped channels', mapped: 'mapped channels' };
            const filterNote = !showFiltered ? ' (filtered-out channels hidden)' : '';
            countEl.textContent = `Showing ${mappingsState.offset} of ${mappingsState.total} ${labelMap[viewMode] || 'channels'}${filterNote}`;
        }
        
        // Show/hide loader based on whether there's more data
        const loader = document.getElementById('mappings-loader');
        if (loader) {
            loader.style.display = mappingsState.hasMore ? 'block' : 'none';
        }
        
    } catch (error) {
        if (mappingsState.offset === 0) {
            container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
        }
        console.error('Error loading mappings:', error);
    } finally {
        mappingsState.loading = false;
    }
}

// Render a single row in the mappings table
function renderMappingRow(item, viewMode) {
    const filteredBadge = item.is_visible === false ? '<span class="badge bg-secondary ms-1">Filtered</span>' : '';
    
    // Determine channel info and mapping info based on view mode
    let channelId, channelName, streamId, accountId, categoryName, mapping;
    
    if (viewMode === 'all') {
        // item is a channel with optional mapping
        channelId = item.id;
        channelName = item.name;
        streamId = item.stream_id;
        accountId = item.account_id;
        categoryName = item.category_name || '-';
        mapping = item.mapping;
    } else if (viewMode === 'unmapped') {
        // item is an unmapped channel
        channelId = item.id;
        channelName = item.name;
        streamId = item.stream_id;
        accountId = item.account_id;
        categoryName = item.category_name || '-';
        mapping = null;
    } else {
        // viewMode === 'mapped' - item is a mapping
        channelId = item.channel_id;
        channelName = item.channel_name || `Channel #${item.channel_id}`;
        streamId = item.stream_id;
        accountId = item.account_id;
        categoryName = '-';
        mapping = {
            id: item.id,
            epg_display_name: item.epg_display_name,
            mapping_type: item.mapping_type,
            confidence: item.confidence,
            is_override: item.is_override
        };
    }
    
    // Build mapping info cell
    let mappingCell, matchInfoCell;
    if (mapping) {
        mappingCell = `<span class="text-success">${mapping.epg_display_name || 'EPG #' + mapping.epg_channel_id}</span>`;
        
        const typeBadge = mapping.mapping_type === 'manual' 
            ? '<span class="badge bg-primary">Manual</span>'
            : mapping.mapping_type === 'provider'
            ? '<span class="badge bg-success">Provider</span>'
            : mapping.mapping_type === 'callsign_tag'
            ? '<span class="badge bg-info">Callsign</span>'
            : mapping.mapping_type === 'fcc_lookup'
            ? '<span class="badge bg-info">FCC</span>'
            : mapping.mapping_type?.includes('auto')
            ? '<span class="badge bg-info">Auto</span>'
            : `<span class="badge bg-secondary">${mapping.mapping_type || 'Unknown'}</span>`;
        
        const confidencePercent = Math.round((mapping.confidence || 0) * 100);
        const overrideIcon = mapping.is_override ? ' <i class="bi bi-pin-fill text-warning" title="Override"></i>' : '';
        
        matchInfoCell = `${typeBadge} ${confidencePercent}%${overrideIcon}`;
    } else {
        mappingCell = '<span class="text-muted">Not mapped</span>';
        matchInfoCell = '-';
    }
    
    // Build actions
    let actions = `<a class="btn btn-outline-success btn-sm" href="/stream/${accountId}/${streamId}.ts" target="_blank" title="Play stream"><i class="bi bi-play-fill"></i></a>`;
    
    if (mapping) {
        actions += ` <button class="btn btn-outline-danger btn-sm" onclick="deleteMapping(${mapping.id})" title="Delete mapping"><i class="bi bi-trash"></i></button>`;
    } else {
        actions += ` <button class="btn btn-outline-primary btn-sm" onclick="showManualMappingModal(${channelId}, '${escapeHtml(channelName)}')" title="Create mapping"><i class="bi bi-link"></i></button>`;
    }
    
    return `
        <tr data-channel-id="${channelId}">
            <td>${channelName}${filteredBadge}</td>
            <td><small class="text-muted">${categoryName}</small></td>
            <td>${mappingCell}</td>
            <td>${matchInfoCell}</td>
            <td><div class="btn-group btn-group-sm">${actions}</div></td>
        </tr>
    `;
}

async function handleMappingsScroll(event) {
    const container = event.target;
    const scrollBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
    
    // Load more when within 100px of bottom
    if (scrollBottom < 100 && !mappingsState.loading && mappingsState.hasMore) {
        await loadMoreMappings();
    }
}

async function loadMoreMappings() {
    if (!mappingsState.hasMore || mappingsState.loading) return;
    
    const loader = document.getElementById('mappings-loader');
    if (loader) loader.style.display = 'block';
    
    await loadMappings(false);
}

async function deleteMapping(id) {
    if (!confirm('Delete this mapping?')) return;
    
    try {
        const response = await fetch(`/api/epg/mappings/${id}`, { method: 'DELETE' });
        if (response.ok) {
            loadMappings();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to delete mapping'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function runAutoMatch() {
    const accountId = document.getElementById('mappingAccountSelect').value;
    const categoryId = document.getElementById('mappingCategorySelect').value;
    const skipThreshold = document.getElementById('skipThresholdSlider').value / 100;
    
    if (!accountId) {
        alert('Please select an account');
        return;
    }
    
    const btn = document.getElementById('auto-match-btn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Matching...';
    
    // Show progress in the list area itself
    const listContainer = document.getElementById('mappings-list');
    const originalListContent = listContainer.innerHTML;
    listContainer.innerHTML = `
        <div class="text-center py-5">
            <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;"></div>
            <h5>Running Auto-Match...</h5>
            <p class="text-muted">Matching channels to EPG data. This may take a moment.</p>
        </div>
    `;
    
    // Hide the results alert initially
    const alertDiv = document.getElementById('autoMatchResultsAlert');
    alertDiv.classList.add('d-none');
    
    try {
        let url = `/api/epg/match/${accountId}`;
        const params = new URLSearchParams();
        if (categoryId) params.append('category_id', categoryId);
        if (skipThreshold !== 0.85) params.append('skip_threshold', skipThreshold);
        if (params.toString()) url += '?' + params.toString();
        
        const response = await fetch(url, { method: 'POST' });
        const result = await response.json();
        
        if (response.ok) {
            const stats = result.stats || {};
            const matchedCount = (stats.matched_exact_id || 0) + (stats.matched_callsign_tag || 0) + 
                                 (stats.matched_fcc_lookup || 0) + (stats.matched_exact_name || 0) + 
                                 (stats.matched_fuzzy || 0);
            
            // Show brief success summary in the alert
            const contentDiv = document.getElementById('autoMatchResultsContent');
            alertDiv.classList.remove('d-none', 'alert-info', 'alert-danger');
            alertDiv.classList.add('alert-success');
            contentDiv.innerHTML = `
                <i class="bi bi-check-circle"></i> <strong>Matched ${matchedCount} channels</strong>
                <span class="ms-2 text-muted small">
                    (Provider: ${stats.matched_exact_id || 0}, 
                    Callsign: ${stats.matched_callsign_tag || 0}, 
                    FCC: ${stats.matched_fcc_lookup || 0}, 
                    Name: ${stats.matched_exact_name || 0}, 
                    Fuzzy: ${stats.matched_fuzzy || 0}, 
                    Skipped: ${stats.skipped_existing || 0}, 
                    Unmatched: ${stats.unmatched || 0})
                </span>
            `;
            
            // Reload the mappings list to show updated results with new mappings visible
            await loadMappings();
        } else {
            // Restore original content on error
            listContainer.innerHTML = originalListContent;
            alertDiv.classList.remove('d-none', 'alert-info', 'alert-success');
            alertDiv.classList.add('alert-danger');
            const contentDiv = document.getElementById('autoMatchResultsContent');
            contentDiv.innerHTML = `<strong><i class="bi bi-x-circle"></i> Error:</strong> ${result.error || 'Match failed'}`;
        }
    } catch (error) {
        // Restore original content on error
        listContainer.innerHTML = originalListContent;
        alertDiv.classList.remove('d-none', 'alert-info', 'alert-success');
        alertDiv.classList.add('alert-danger');
        const contentDiv = document.getElementById('autoMatchResultsContent');
        contentDiv.innerHTML = `<strong><i class="bi bi-x-circle"></i> Error:</strong> ${error.message}`;
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

function showManualMappingModal(channelId, channelName) {
    document.getElementById('manualMappingChannelId').value = channelId;
    document.getElementById('manualMappingChannel').textContent = channelName;
    document.getElementById('manualMappingEpgSearch').value = '';
    document.getElementById('manualMappingEpgChannel').innerHTML = '<option value="">Search for EPG channels above...</option>';
    manualMappingModal.show();
}

async function searchEpgChannels() {
    const search = document.getElementById('manualMappingEpgSearch').value;
    if (search.length < 2) return;
    
    try {
        const response = await fetch(`/api/epg/channels?search=${encodeURIComponent(search)}&limit=20`);
        const data = await response.json();
        
        const select = document.getElementById('manualMappingEpgChannel');
        select.innerHTML = '';
        
        if (data.channels.length === 0) {
            select.innerHTML = '<option value="">No channels found</option>';
            return;
        }
        
        data.channels.forEach(ch => {
            select.innerHTML += `<option value="${ch.id}">${ch.display_name} (${ch.channel_id})</option>`;
        });
    } catch (error) {
        console.error('Error searching EPG channels:', error);
    }
}

async function saveManualMapping() {
    const channelId = document.getElementById('manualMappingChannelId').value;
    const epgChannelId = document.getElementById('manualMappingEpgChannel').value;
    
    if (!channelId || !epgChannelId) {
        alert('Please select an EPG channel');
        return;
    }
    
    try {
        const response = await fetch('/api/epg/mappings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                channel_id: parseInt(channelId),
                epg_channel_id: parseInt(epgChannelId)
            })
        });
        
        if (response.ok) {
            manualMappingModal.hide();
            loadMappings();
            alert('✓ Mapping created');
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to create mapping'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// ============================================================================
// Coverage Stats
// ============================================================================

async function loadCoverage() {
    const container = document.getElementById('coverage-summary');
    const content = document.getElementById('coverage-content');
    container.style.display = 'block';
    content.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        const response = await fetch('/api/epg/coverage');
        const stats = await response.json();
        
        const coveragePercent = stats.total_channels > 0 
            ? ((stats.channels_with_epg_mapping / stats.total_channels) * 100).toFixed(1)
            : 0;
            
        content.innerHTML = `
            <div class="row">
                <div class="col-md-3 text-center">
                    <h3 class="text-primary">${stats.total_channels}</h3>
                    <small>Total Channels</small>
                </div>
                <div class="col-md-3 text-center">
                    <h3 class="text-success">${stats.channels_with_epg_mapping}</h3>
                    <small>With EPG Mapping</small>
                </div>
                <div class="col-md-3 text-center">
                    <h3 class="text-info">${stats.epg_sources}</h3>
                    <small>EPG Sources</small>
                </div>
                <div class="col-md-3 text-center">
                    <h3 class="text-warning">${coveragePercent}%</h3>
                    <small>Coverage</small>
                </div>
            </div>
            <div class="progress mt-3" style="height: 25px;">
                <div class="progress-bar bg-success" style="width: ${coveragePercent}%">${coveragePercent}% covered</div>
            </div>
        `;
    } catch (error) {
        content.innerHTML = `<div class="alert alert-danger">Error loading coverage: ${error.message}</div>`;
    }
}

// ============================================================================
// Schedules Direct Functions
// ============================================================================

async function loadSdStatus() {
    const container = document.getElementById('sd-status-content');
    
    try {
        const response = await fetch('/api/epg/sd/status');
        const status = await response.json();
        
        if (status.status === 'online') {
            container.innerHTML = `
                <div class="alert alert-success mb-0">
                    <i class="bi bi-check-circle-fill"></i> Service is <strong>Online</strong>
                    <br><small>Message: ${status.message || 'All systems operational'}</small>
                </div>
            `;
        } else {
            container.innerHTML = `
                <div class="alert alert-warning mb-0">
                    <i class="bi bi-exclamation-triangle-fill"></i> Service status: <strong>${status.status || 'Unknown'}</strong>
                    <br><small>${status.message || ''}</small>
                </div>
            `;
        }
    } catch (error) {
        container.innerHTML = `
            <div class="alert alert-secondary mb-0">
                <i class="bi bi-question-circle"></i> Could not check SD status: ${error.message}
            </div>
        `;
    }
}

async function testSdCredentials() {
    const username = document.getElementById('sdUsername').value;
    const password = document.getElementById('sdPassword').value;
    const resultDiv = document.getElementById('sdCredentialsResult');
    
    if (!username || !password) {
        alert('Please enter credentials first');
        return;
    }
    
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = '<div class="alert alert-secondary"><span class="spinner-border spinner-border-sm"></span> Testing...</div>';
    
    try {
        const response = await fetch('/api/epg/sd/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
        
        const result = await response.json();
        
        if (result.success) {
            resultDiv.innerHTML = `
                <div class="alert alert-success">
                    <i class="bi bi-check-circle"></i> Credentials valid!
                    ${result.account_info ? `<br><small>Account: ${JSON.stringify(result.account_info)}</small>` : ''}
                </div>
            `;
        } else {
            resultDiv.innerHTML = `<div class="alert alert-danger"><i class="bi bi-x-circle"></i> ${result.error || 'Invalid credentials'}</div>`;
        }
    } catch (error) {
        resultDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function loadSdLineups() {
    const sourceId = document.getElementById('sdSourceSelect').value;
    const container = document.getElementById('sd-lineups-list');
    const searchBtn = document.getElementById('searchLineupsModalBtn');
    
    if (!sourceId) {
        searchBtn.disabled = true;
        searchBtn.title = 'Select a Schedules Direct source first';
        container.innerHTML = '<div class="text-center text-muted py-3">Select a Schedules Direct source to view lineups</div>';
        return;
    }
    
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        const response = await fetch(`/api/epg/sd/lineups?source_id=${sourceId}`);
        const result = await response.json();
        
        // Check if response is an error
        if (result.error || result.success === false) {
            container.innerHTML = `<div class="alert alert-danger">${result.error || 'Failed to load lineups'}</div>`;
            searchBtn.disabled = true;
            return;
        }
        
        // New response format has lineups array and limit info
        const lineups = result.lineups || [];
        const accountLineups = result.account_lineups || 0;
        const maxLineups = result.max_lineups || 4;
        const atLimit = accountLineups >= maxLineups;
        
        // Update search button based on lineup limit
        if (atLimit) {
            searchBtn.disabled = true;
            searchBtn.title = `Lineup limit reached (${accountLineups}/${maxLineups}). Remove a lineup to add more.`;
        } else {
            searchBtn.disabled = false;
            searchBtn.title = `Search for lineups to add (${accountLineups}/${maxLineups} used)`;
        }
        
        // Build lineup status header
        let html = `
            <div class="alert ${atLimit ? 'alert-warning' : 'alert-info'} mb-3">
                <i class="bi bi-${atLimit ? 'exclamation-triangle' : 'info-circle'}"></i>
                <strong>SD Account Lineups:</strong> ${accountLineups} of ${maxLineups} used
                ${atLimit ? '<br><small>Remove a lineup from your SD account to add more.</small>' : ''}
            </div>
        `;
        
        if (lineups.length === 0) {
            if (atLimit) {
                html += `
                    <div class="alert alert-secondary">
                        No lineups added to this source yet. Your SD account has ${accountLineups} lineup(s) 
                        that may be added to other sources or managed via schedulesdirect.org.
                    </div>
                `;
            } else {
                html += `
                    <div class="alert alert-secondary">
                        No lineups added yet. Use "Search Lineups" to find and add lineups for your area.
                    </div>
                `;
            }
            container.innerHTML = html;
            return;
        }
        
        html += '<div class="list-group">';
        for (const lineup of lineups) {
            html += `
                <div class="list-group-item">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong>${lineup.name || lineup.lineup_id}</strong>
                            <br><small class="text-muted">${lineup.location || ''} - ${lineup.lineup_type || ''}</small>
                            <br><small>${lineup.channel_count} channels</small>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-primary" onclick="viewStations(${lineup.id}, '${escapeHtml(lineup.name || lineup.lineup_id)}')">
                                <i class="bi bi-list"></i> Stations
                            </button>
                            <button class="btn btn-outline-success" onclick="syncSdLineup(${lineup.id})">
                                <i class="bi bi-arrow-repeat"></i> Sync
                            </button>
                            <button class="btn btn-outline-danger" onclick="removeSdLineup(${lineup.id})">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        html += '</div>';
        container.innerHTML = html;
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function searchLineups() {
    const sourceId = document.getElementById('sdSourceSelect').value;
    if (!sourceId) {
        alert('Please select a Schedules Direct source first');
        return;
    }
    
    const country = document.getElementById('searchCountry').value;
    const postalcode = document.getElementById('searchPostalCode').value;
    const container = document.getElementById('lineupSearchResults');
    
    if (!postalcode) {
        alert('Please enter a postal code');
        return;
    }
    
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/search?source_id=${sourceId}&country=${country}&postalcode=${postalcode}`);
        const result = await response.json();
        
        if (!result.success) {
            container.innerHTML = `<div class="alert alert-danger">${result.error || 'Search failed'}</div>`;
            return;
        }
        
        const lineups = Array.isArray(result.lineups) ? result.lineups : [];
        
        if (lineups.length === 0) {
            container.innerHTML = '<div class="alert alert-info">No lineups found for this location</div>';
            return;
        }
        
        let html = '<div class="list-group">';
        for (const lineup of lineups) {
            html += `
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${lineup.name || lineup.lineup}</strong>
                        <br><small class="text-muted">${lineup.location || ''}</small>
                        <br><small>Type: ${lineup.type || lineup.transport || '-'}</small>
                    </div>
                    <button class="btn btn-sm btn-primary" onclick="addSdLineup('${lineup.lineup}', '${escapeHtml(lineup.name || '')}', '${escapeHtml(lineup.location || '')}', '${lineup.type || lineup.transport || ''}')">
                        <i class="bi bi-plus"></i> Add
                    </button>
                </div>
            `;
        }
        html += '</div>';
        container.innerHTML = html;
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function addSdLineup(lineupId, name, location, type) {
    const sourceId = document.getElementById('sdSourceSelect').value;
    
    try {
        const response = await fetch('/api/epg/sd/lineups?sync=true', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                source_id: parseInt(sourceId),
                lineup_id: lineupId,
                name: name,
                location: location,
                lineup_type: type
            })
        });
        
        const result = await response.json();
        
        if (response.ok) {
            searchLineupModal.hide();
            loadSdLineups();
            alert(`✓ Lineup added! ${result.message}`);
        } else {
            // Check for lineup limit error
            if (result.limit_reached) {
                alert(`⚠️ Lineup limit reached!\n\nYour Schedules Direct account allows a maximum of ${result.max_lineups} lineups.\n\nYou currently have ${result.current_count} lineup(s). Please remove a lineup before adding a new one.`);
            } else {
                alert('Error: ' + (result.error || 'Failed to add lineup'));
            }
            // Refresh to update the limit display
            loadSdLineups();
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function syncSdLineup(lineupId) {
    const btn = event.target.closest('button');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/${lineupId}/sync`, { method: 'POST' });
        const result = await response.json();
        
        if (response.ok) {
            loadSdLineups();
            alert(`✓ Synced ${result.channels_synced || 0} channels`);
        } else {
            alert('Error: ' + (result.error || 'Sync failed'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

async function removeSdLineup(lineupId) {
    if (!confirm('Remove this lineup and all its stations?')) return;
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/${lineupId}`, { method: 'DELETE' });
        if (response.ok) {
            loadSdLineups();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to remove lineup'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

let currentStations = [];

async function viewStations(lineupId, lineupName) {
    document.getElementById('sdStationsModalTitle').textContent = `Stations: ${lineupName}`;
    document.getElementById('stationSearch').value = '';
    const container = document.getElementById('sd-stations-list');
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    sdStationsModal.show();
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/${lineupId}/stations`);
        const data = await response.json();
        currentStations = data.stations || [];
        renderStations(currentStations);
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

function filterStations() {
    const search = document.getElementById('stationSearch').value.toLowerCase();
    const filtered = currentStations.filter(s => 
        (s.callsign || '').toLowerCase().includes(search) ||
        (s.name || '').toLowerCase().includes(search) ||
        (s.channel_number || '').toString().includes(search)
    );
    renderStations(filtered);
}

function renderStations(stations) {
    const container = document.getElementById('sd-stations-list');
    
    if (stations.length === 0) {
        container.innerHTML = '<div class="text-center text-muted py-3">No stations found</div>';
        return;
    }
    
    let html = '<table class="table table-striped table-sm"><thead><tr>';
    html += '<th>Ch #</th><th>Callsign</th><th>Name</th><th>Affiliate</th><th>Logo</th>';
    html += '</tr></thead><tbody>';
    
    for (const s of stations) {
        html += `
            <tr>
                <td>${s.channel_number || '-'}</td>
                <td><strong>${s.callsign || '-'}</strong></td>
                <td>${s.name || '-'}</td>
                <td>${s.affiliate || '-'}</td>
                <td>${s.logo_url ? `<img src="${s.logo_url}" style="max-height: 24px;">` : '-'}</td>
            </tr>
        `;
    }
    
    html += '</tbody></table>';
    container.innerHTML = html;
}

// ============================================================================
// Utility Functions
// ============================================================================

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ============================================================================
// XMLTV Grabbers
// ============================================================================

let xmltvGrabbers = [];

async function loadXmltvGrabbers() {
    const container = document.getElementById('xmltv-grabbers-list');
    
    try {
        const response = await fetch('/api/xmltv/grabbers');
        xmltvGrabbers = await response.json();
        
        if (xmltvGrabbers.length === 0) {
            container.innerHTML = `
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle"></i> No XMLTV grabbers found.
                    <p class="small mb-0 mt-2">Make sure the XMLTV utilities are installed in the Docker container.</p>
                </div>
            `;
            return;
        }
        
        let html = '<div class="table-responsive"><table class="table table-striped table-sm">';
        html += '<thead><tr><th>Grabber</th><th>Description</th><th>Capabilities</th><th>Actions</th></tr></thead><tbody>';
        
        for (const grabber of xmltvGrabbers) {
            const caps = (grabber.capabilities || []).slice(0, 3).join(', ');
            html += `
                <tr>
                    <td><code>${grabber.name}</code></td>
                    <td>${grabber.description || '-'}</td>
                    <td><small class="text-muted">${caps}</small></td>
                    <td>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-info" onclick="viewGrabberChannels('${grabber.name}')" title="List Channels">
                                <i class="bi bi-list"></i>
                            </button>
                            <button class="btn btn-outline-primary" onclick="quickCreateGrabberSource('${grabber.name}')" title="Create Source">
                                <i class="bi bi-plus"></i>
                            </button>
                        </div>
                    </td>
                </tr>
            `;
        }
        
        html += '</tbody></table></div>';
        container.innerHTML = html;
        
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error loading grabbers: ${error.message}</div>`;
    }
}

async function populateGrabberSelect() {
    const select = document.getElementById('grabberSelect');
    
    // Only fetch if not already loaded
    if (xmltvGrabbers.length === 0) {
        try {
            const response = await fetch('/api/xmltv/grabbers');
            xmltvGrabbers = await response.json();
        } catch (error) {
            console.error('Error loading grabbers:', error);
            return;
        }
    }
    
    select.innerHTML = '<option value="">Select a grabber...</option>';
    for (const grabber of xmltvGrabbers) {
        select.innerHTML += `<option value="${grabber.name}">${grabber.name} - ${grabber.description || 'No description'}</option>`;
    }
}

async function loadXmltvConfigs() {
    const container = document.getElementById('xmltv-configs-list');
    
    try {
        const response = await fetch('/api/xmltv/configs');
        const data = await response.json();
        const configs = data.configs || [];
        
        if (configs.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No saved configurations</div>';
            return;
        }
        
        let html = '<div class="list-group">';
        for (const config of configs) {
            html += `
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${config.name}</strong>
                        <br><small class="text-muted">Modified: ${new Date(config.modified).toLocaleString()}</small>
                    </div>
                    <button class="btn btn-outline-danger btn-sm" onclick="deleteXmltvConfig('${config.name}')">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            `;
        }
        html += '</div>';
        container.innerHTML = html;
        
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function deleteXmltvConfig(configName) {
    if (!confirm(`Delete configuration "${configName}"?`)) return;
    
    try {
        const response = await fetch(`/api/xmltv/configs/${configName}`, { method: 'DELETE' });
        if (response.ok) {
            loadXmltvConfigs();
            alert('✓ Configuration deleted');
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to delete'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function testGrabber() {
    const grabberName = document.getElementById('grabberSelect').value;
    const configName = document.getElementById('grabberConfigName').value;
    const resultDiv = document.getElementById('grabberTestResult');
    
    if (!grabberName) {
        alert('Please select a grabber first');
        return;
    }
    
    const btn = document.getElementById('testGrabberBtn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Testing...';
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = '<div class="alert alert-info">Testing grabber, please wait...</div>';
    
    try {
        const response = await fetch(`/api/xmltv/grabbers/${grabberName}/test`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ config_name: configName || null })
        });
        const result = await response.json();
        
        if (result.success) {
            resultDiv.innerHTML = `
                <div class="alert alert-success">
                    <i class="bi bi-check-circle"></i> Test passed!
                    <br>Channels: ${result.channels}, Programs: ${result.programs}
                </div>
            `;
        } else {
            resultDiv.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-x-circle"></i> Test failed: ${result.message}
                </div>
            `;
        }
    } catch (error) {
        resultDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

async function viewGrabberChannels(grabberName) {
    alert(`Loading channels from ${grabberName}... This may take a moment.`);
    
    try {
        const response = await fetch(`/api/xmltv/grabbers/${grabberName}/channels`);
        const data = await response.json();
        
        if (data.error) {
            alert('Error: ' + data.error);
            return;
        }
        
        const channels = data.channels || [];
        let msg = `Found ${channels.length} channels:\n\n`;
        msg += channels.slice(0, 20).map(c => `${c.id}: ${c.name}`).join('\n');
        if (channels.length > 20) {
            msg += `\n... and ${channels.length - 20} more`;
        }
        alert(msg);
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

function quickCreateGrabberSource(grabberName) {
    // Pre-fill the source modal for this grabber
    document.getElementById('sourceId').value = '';
    document.getElementById('sourceForm').reset();
    document.getElementById('sourceType').value = 'xmltv_grabber';
    document.getElementById('sourceName').value = `XMLTV - ${grabberName}`;
    onSourceTypeChange();
    
    // Set the grabber after the select is populated
    setTimeout(() => {
        document.getElementById('grabberSelect').value = grabberName;
    }, 100);
    
    document.getElementById('sourceModalLabel').textContent = 'Add EPG Source';
    sourceModal.show();
}
</script>
{% endblock %}
