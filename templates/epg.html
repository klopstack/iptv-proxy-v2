{% extends "base.html" %}

{% block title %}EPG Sources - IPTV Proxy{% endblock %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pb-2 mb-3 border-bottom">
    <h1 class="h2"><i class="bi bi-calendar-event"></i> EPG Sources</h1>
    <div>
        <button class="btn btn-outline-info me-2" id="refresh-coverage-btn">
            <i class="bi bi-bar-chart"></i> View Coverage
        </button>
        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#sourceModal" id="add-source-btn">
            <i class="bi bi-plus-circle"></i> Add EPG Source
        </button>
    </div>
</div>

<!-- Coverage Summary -->
<div id="coverage-summary" class="row mb-4" style="display: none;">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span><i class="bi bi-bar-chart-fill"></i> EPG Coverage Summary</span>
                <button type="button" class="btn-close" onclick="document.getElementById('coverage-summary').style.display='none'"></button>
            </div>
            <div class="card-body" id="coverage-content">
                <div class="text-center">
                    <div class="spinner-border" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Nav Tabs -->
<ul class="nav nav-tabs mb-4" id="epgTabs" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="sources-tab" data-bs-toggle="tab" data-bs-target="#sources-pane" type="button">
            <i class="bi bi-database"></i> EPG Sources
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="channels-tab" data-bs-toggle="tab" data-bs-target="#channels-pane" type="button">
            <i class="bi bi-list"></i> EPG Channels
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="mappings-tab" data-bs-toggle="tab" data-bs-target="#mappings-pane" type="button">
            <i class="bi bi-link-45deg"></i> Channel Mappings
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="sd-tab" data-bs-toggle="tab" data-bs-target="#sd-pane" type="button">
            <i class="bi bi-broadcast-pin"></i> Schedules Direct
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="xmltv-tab" data-bs-toggle="tab" data-bs-target="#xmltv-pane" type="button">
            <i class="bi bi-terminal"></i> XMLTV Grabbers
        </button>
    </li>
</ul>

<div class="tab-content" id="epgTabContent">
    <!-- EPG Sources Tab -->
    <div class="tab-pane fade show active" id="sources-pane" role="tabpanel">
        <div id="sources-list">
            <div class="text-center">
                <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- EPG Channels Tab -->
    <div class="tab-pane fade" id="channels-pane" role="tabpanel">
        <div class="row mb-3">
            <div class="col-md-4">
                <label for="channelSourceSelect" class="form-label">Filter by Source:</label>
                <select class="form-select" id="channelSourceSelect">
                    <option value="">All Sources</option>
                </select>
            </div>
            <div class="col-md-4">
                <label for="channelSearch" class="form-label">Search:</label>
                <input type="text" class="form-control" id="channelSearch" placeholder="Search channels...">
            </div>
        </div>
        <div id="channels-list">
            <div class="text-center text-muted py-4">
                Select a source or search to view EPG channels
            </div>
        </div>
    </div>

    <!-- Channel Mappings Tab -->
    <div class="tab-pane fade" id="mappings-pane" role="tabpanel">
        <div class="row mb-3">
            <div class="col-md-2">
                <label for="mappingAccountSelect" class="form-label">Filter by Account:</label>
                <select class="form-select" id="mappingAccountSelect">
                    <option value="">All Accounts</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="mappingCategorySelect" class="form-label">Filter by Category:</label>
                <select class="form-select" id="mappingCategorySelect">
                    <option value="">All Categories</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="mappingEpgSourceSelect" class="form-label">EPG Provider:</label>
                <select class="form-select" id="mappingEpgSourceSelect">
                    <option value="">All Sources</option>
                </select>
            </div>
            <div class="col-md-2">
                <label for="mappingViewSelect" class="form-label">Show:</label>
                <select class="form-select" id="mappingViewSelect">
                    <option value="all">All Channels</option>
                    <option value="unmapped">Unmapped Only</option>
                    <option value="mapped">Mapped Only</option>
                </select>
            </div>
            <div class="col-md-2">
                <div class="form-check mt-4">
                    <input class="form-check-input" type="checkbox" id="showFilteredChannels">
                    <label class="form-check-label" for="showFilteredChannels">
                        Include filtered-out
                    </label>
                </div>
            </div>
            <div class="col-md-2 text-end">
                <div class="btn-group mt-3" role="group">
                    <button type="button" class="btn btn-success" id="auto-match-btn" disabled>
                        <i class="bi bi-magic"></i> Auto-Match
                    </button>
                    <button type="button" class="btn btn-success dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" disabled id="auto-match-dropdown">
                        <span class="visually-hidden">Toggle Dropdown</span>
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end">
                        <li><a class="dropdown-item" href="/epg-match-rules"><i class="bi bi-gear"></i> Configure Match Rules...</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item text-danger" href="#" id="clear-category-mappings-btn"><i class="bi bi-trash"></i> Clear Category Mappings...</a></li>
                    </ul>
                </div>
            </div>
        </div>
        <!-- Account Ruleset Info -->
        <div class="row mb-3" id="account-ruleset-info" style="display: none;">
            <div class="col-12">
                <div class="alert alert-info py-2 mb-0 d-flex align-items-center justify-content-between">
                    <span id="ruleset-info-text"><i class="bi bi-info-circle"></i> Loading ruleset info...</span>
                    <a href="/epg-match-rules" class="btn btn-sm btn-outline-primary">Manage Rules</a>
                </div>
            </div>
        </div>
        <!-- Auto-Match Results Alert -->
        <div id="autoMatchResultsAlert" class="alert alert-dismissible fade show d-none" role="alert">
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            <div id="autoMatchResultsContent"></div>
        </div>
        <div id="mappings-list">
            <div class="text-center text-muted py-4">
                Select an account to view channel mappings
            </div>
        </div>
    </div>

    <!-- Schedules Direct Tab -->
    <div class="tab-pane fade" id="sd-pane" role="tabpanel">
        <div class="row">
            <div class="col-md-8">
                <!-- SD Status -->
                <div class="card mb-4">
                    <div class="card-header">
                        <i class="bi bi-broadcast-pin"></i> Schedules Direct Service Status
                    </div>
                    <div class="card-body" id="sd-status-content">
                        <div class="text-center">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- SD Lineups -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span><i class="bi bi-list-ul"></i> SD Lineups</span>
                        <button class="btn btn-sm btn-outline-primary" id="searchLineupsModalBtn" data-bs-toggle="modal" data-bs-target="#searchLineupModal" disabled title="Select a Schedules Direct source first">
                            <i class="bi bi-search"></i> Search Lineups
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="sdSourceSelect" class="form-label">Select SD Source:</label>
                            <select class="form-select" id="sdSourceSelect">
                                <option value="">-- Select a Schedules Direct source --</option>
                            </select>
                            <div class="form-text text-muted">Select a source to enable Search Lineups</div>
                        </div>
                        <div id="sd-lineups-list">
                            <div class="text-center text-muted py-3">
                                Select a Schedules Direct source to view lineups
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card bg-light">
                    <div class="card-header">
                        <i class="bi bi-info-circle"></i> About Schedules Direct
                    </div>
                    <div class="card-body">
                        <p class="small">
                            <a href="https://schedulesdirect.org/" target="_blank">Schedules Direct</a> is a 
                            non-profit service providing North American TV listings data.
                        </p>
                        <p class="small">
                            To use SD, create an EPG source of type "Schedules Direct" and enter your credentials.
                        </p>
                        <ul class="small">
                            <li>Add lineups for your area</li>
                            <li>Sync station data</li>
                            <li>Match stations to your channels</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- XMLTV Grabbers Tab -->
    <div class="tab-pane fade" id="xmltv-pane" role="tabpanel">
        <div class="row">
            <div class="col-md-8">
                <!-- Installed Grabbers -->
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <span><i class="bi bi-terminal"></i> Installed XMLTV Grabbers</span>
                        <button class="btn btn-sm btn-outline-primary" onclick="loadXmltvGrabbers()">
                            <i class="bi bi-arrow-repeat"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body" id="xmltv-grabbers-list">
                        <div class="text-center">
                            <div class="spinner-border" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Grabber Configurations -->
                <div class="card mb-4">
                    <div class="card-header">
                        <i class="bi bi-gear"></i> Grabber Configurations
                    </div>
                    <div class="card-body" id="xmltv-configs-list">
                        <div class="text-center text-muted py-3">
                            Configurations will appear here after grabbers are loaded
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="card bg-light">
                    <div class="card-header">
                        <i class="bi bi-info-circle"></i> About XMLTV Grabbers
                    </div>
                    <div class="card-body">
                        <p class="small">
                            <a href="https://xmltv.org/" target="_blank">XMLTV</a> provides grabber tools
                            (tv_grab_*) to fetch EPG data from various regional sources.
                        </p>
                        <p class="small">
                            Available grabbers depend on the Docker image. Common grabbers include:
                        </p>
                        <ul class="small">
                            <li><code>tv_grab_zz_sdjson</code> - Schedules Direct</li>
                            <li><code>tv_grab_na_dd</code> - DataDirect (NA)</li>
                            <li><code>tv_grab_uk_tvguide</code> - UK TV Guide</li>
                            <li>And many more region-specific grabbers</li>
                        </ul>
                        <p class="small">
                            To use a grabber:
                        </p>
                        <ol class="small">
                            <li>Configure the grabber (credentials, region, etc.)</li>
                            <li>Create an EPG source of type "XMLTV Grabber"</li>
                            <li>Select the grabber and configuration</li>
                            <li>Sync to fetch EPG data</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add/Edit EPG Source Modal -->
<div class="modal fade" id="sourceModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="sourceModalLabel">Add EPG Source</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="sourceForm">
                    <input type="hidden" id="sourceId">
                    <div class="mb-3">
                        <label for="sourceName" class="form-label">Name *</label>
                        <input type="text" class="form-control" id="sourceName" required>
                    </div>
                    <div class="mb-3">
                        <label for="sourceType" class="form-label">Source Type *</label>
                        <select class="form-select" id="sourceType" required>
                            <option value="">Select a type...</option>
                            <option value="provider">IPTV Provider (from account)</option>
                            <option value="xmltv_url">External XMLTV URL</option>
                            <option value="schedules_direct">Schedules Direct</option>
                            <option value="xmltv_grabber">XMLTV Grabber (tv_grab_*)</option>
                        </select>
                    </div>

                    <!-- Provider-specific fields -->
                    <div id="providerFields" style="display: none;">
                        <div class="mb-3">
                            <label for="sourceAccountId" class="form-label">Account *</label>
                            <select class="form-select" id="sourceAccountId">
                                <option value="">Select an account...</option>
                            </select>
                            <div class="form-text">Select the IPTV account to pull EPG data from</div>
                        </div>
                    </div>

                    <!-- XMLTV URL fields -->
                    <div id="xmltvFields" style="display: none;">
                        <div class="mb-3">
                            <label for="sourceUrl" class="form-label">XMLTV URL *</label>
                            <input type="url" class="form-control" id="sourceUrl" placeholder="https://example.com/epg.xml">
                            <div class="form-text">URL to the XMLTV file</div>
                        </div>
                    </div>

                    <!-- Schedules Direct fields -->
                    <div id="sdFields" style="display: none;">
                        <div class="mb-3">
                            <label for="sdUsername" class="form-label">SD Username *</label>
                            <input type="text" class="form-control" id="sdUsername">
                        </div>
                        <div class="mb-3">
                            <label for="sdPassword" class="form-label">SD Password *</label>
                            <input type="password" class="form-control" id="sdPassword">
                        </div>
                        <button type="button" class="btn btn-outline-secondary btn-sm mb-3" id="testSdCredentialsBtn">
                            <i class="bi bi-check-circle"></i> Test Credentials
                        </button>
                        <div id="sdCredentialsResult" class="mb-3" style="display: none;"></div>
                    </div>

                    <!-- XMLTV Grabber fields -->
                    <div id="grabberFields" style="display: none;">
                        <div class="mb-3">
                            <label for="grabberSelect" class="form-label">Grabber *</label>
                            <select class="form-select" id="grabberSelect">
                                <option value="">Select a grabber...</option>
                            </select>
                            <div class="form-text">Select an installed XMLTV grabber</div>
                        </div>
                        <div class="mb-3">
                            <label for="grabberConfigName" class="form-label">Configuration Name</label>
                            <input type="text" class="form-control" id="grabberConfigName" placeholder="my-config">
                            <div class="form-text">Optional: Name of a saved configuration</div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="grabberDays" class="form-label">Days to Fetch</label>
                                    <input type="number" class="form-control" id="grabberDays" value="7" min="1" max="14">
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="grabberOffset" class="form-label">Day Offset</label>
                                    <input type="number" class="form-control" id="grabberOffset" value="0" min="0" max="14">
                                </div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-outline-secondary btn-sm mb-3" id="testGrabberBtn">
                            <i class="bi bi-check-circle"></i> Test Grabber
                        </button>
                        <div id="grabberTestResult" class="mb-3" style="display: none;"></div>
                    </div>

                    <div class="mb-3">
                        <label for="sourcePriority" class="form-label">Priority</label>
                        <input type="number" class="form-control" id="sourcePriority" value="100" min="1" max="1000">
                        <div class="form-text">Lower numbers = higher priority when merging EPG data</div>
                    </div>
                    <div class="mb-3 form-check">
                        <input type="checkbox" class="form-check-input" id="sourceEnabled" checked>
                        <label class="form-check-label" for="sourceEnabled">Enabled</label>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="save-source-btn">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Search Lineups Modal -->
<div class="modal fade" id="searchLineupModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Search SD Lineups</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="row mb-3">
                    <div class="col-md-4">
                        <label for="searchCountry" class="form-label">Country</label>
                        <select class="form-select" id="searchCountry">
                            <option value="USA">USA</option>
                            <option value="CAN">Canada</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="searchPostalCode" class="form-label">Postal/ZIP Code</label>
                        <input type="text" class="form-control" id="searchPostalCode" placeholder="12345">
                    </div>
                    <div class="col-md-4 d-flex align-items-end">
                        <button type="button" class="btn btn-primary w-100" id="searchLineupsBtn">
                            <i class="bi bi-search"></i> Search
                        </button>
                    </div>
                </div>
                <div id="lineupSearchResults">
                    <div class="text-center text-muted py-3">
                        Enter a postal code to search for available lineups
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Manual Mapping Modal -->
<div class="modal fade" id="manualMappingModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Create Manual Mapping</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label">Channel</label>
                    <div id="manualMappingChannel" class="form-control-plaintext fw-bold"></div>
                    <input type="hidden" id="manualMappingChannelId">
                </div>
                <div class="mb-3">
                    <label for="manualMappingEpgSource" class="form-label">EPG Provider</label>
                    <select class="form-select" id="manualMappingEpgSource">
                        <option value="">All Sources</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label for="manualMappingEpgChannel" class="form-label">EPG Channel *</label>
                    <input type="text" class="form-control" id="manualMappingEpgSearch" placeholder="Search EPG channels (fuzzy match supported)...">
                    <small class="text-muted">Try searching multiple words like "CNN HD" or "ESPN 2"</small>
                    <div id="epgChannelListContainer" class="border rounded mt-2" style="max-height: 250px; overflow-y: auto;">
                        <div class="list-group list-group-flush" id="epgChannelList">
                            <div class="list-group-item text-muted">Type to search EPG channels...</div>
                        </div>
                        <div id="epgChannelLoader" class="text-center py-2" style="display: none;">
                            <div class="spinner-border spinner-border-sm" role="status"></div>
                            <span class="ms-2">Loading more...</span>
                        </div>
                    </div>
                    <input type="hidden" id="manualMappingEpgChannel">
                    <div id="selectedEpgChannel" class="alert alert-success mt-2" style="display: none;">
                        <strong>Selected:</strong> <span id="selectedEpgChannelName"></span>
                        <button type="button" class="btn-close float-end" onclick="clearSelectedEpgChannel()"></button>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="manualMappingTimeOffset" class="form-label">Time Offset (hours)</label>
                    <input type="number" class="form-control" id="manualMappingTimeOffset" value="0" min="-12" max="12">
                    <small class="text-muted">Use negative values for west coast feeds (e.g., -3), positive for east coast delays</small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveManualMappingBtn">Create Mapping</button>
            </div>
        </div>
    </div>
</div>

<!-- SD Stations Modal -->
<div class="modal fade" id="sdStationsModal" tabindex="-1">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="sdStationsModalTitle">Lineup Stations</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <input type="text" class="form-control" id="stationSearch" placeholder="Search stations...">
                </div>
                <div id="sd-stations-list" style="max-height: 400px; overflow-y: auto;">
                    <div class="text-center">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Source Mappings Modal -->
<div class="modal fade" id="sourceMappingsModal" tabindex="-1">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="sourceMappingsModalTitle">EPG Mappings</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <input type="text" class="form-control" id="sourceMappingsSearch" placeholder="Search channels...">
                </div>
                <div id="source-mappings-list" style="max-height: 500px; overflow-y: auto;">
                    <div class="text-center">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
                <div id="source-mappings-pagination" class="d-flex justify-content-between align-items-center mt-3">
                    <span id="mappings-showing-text" class="text-muted"></span>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-secondary" id="mappings-prev-btn" disabled>Previous</button>
                        <button class="btn btn-outline-secondary" id="mappings-next-btn" disabled>Next</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let sources = [];
let accounts = [];
const sourceModal = new bootstrap.Modal(document.getElementById('sourceModal'));
const searchLineupModal = new bootstrap.Modal(document.getElementById('searchLineupModal'));
const manualMappingModal = new bootstrap.Modal(document.getElementById('manualMappingModal'));
const sdStationsModal = new bootstrap.Modal(document.getElementById('sdStationsModal'));
const sourceMappingsModal = new bootstrap.Modal(document.getElementById('sourceMappingsModal'));

// Source mappings state
let currentSourceMappings = {
    sourceId: null,
    sourceName: '',
    offset: 0,
    limit: 50,
    search: ''
};

// ============================================================================
// Initialization
// ============================================================================

document.addEventListener('DOMContentLoaded', async () => {
    await loadAccounts();
    await loadSources();
    loadSdStatus();
    
    // Set up event listeners
    document.getElementById('sourceType').addEventListener('change', onSourceTypeChange);
    document.getElementById('save-source-btn').addEventListener('click', saveSource);
    document.getElementById('testSdCredentialsBtn').addEventListener('click', testSdCredentials);
    document.getElementById('testGrabberBtn').addEventListener('click', testGrabber);
    document.getElementById('refresh-coverage-btn').addEventListener('click', loadCoverage);
    document.getElementById('add-source-btn').addEventListener('click', () => {
        document.getElementById('sourceId').value = '';
        document.getElementById('sourceForm').reset();
        document.getElementById('sourceModalLabel').textContent = 'Add EPG Source';
        onSourceTypeChange();
    });
    
    // Channels tab
    document.getElementById('channelSourceSelect').addEventListener('change', loadEpgChannels);
    document.getElementById('channelSearch').addEventListener('input', debounce(loadEpgChannels, 300));
    
    // Mappings tab
    document.getElementById('mappingAccountSelect').addEventListener('change', async (e) => {
        await loadCategoriesForAccount(e.target.value);
        document.getElementById('mappingCategorySelect').value = '';
        updateAutoMatchButton();
        loadMappings();
    });
    document.getElementById('mappingCategorySelect').addEventListener('change', loadMappings);
    document.getElementById('mappingViewSelect').addEventListener('change', loadMappings);
    document.getElementById('showFilteredChannels').addEventListener('change', loadMappings);
    document.getElementById('auto-match-btn').addEventListener('click', () => runAutoMatch());
    document.getElementById('clear-category-mappings-btn').addEventListener('click', (e) => {
        e.preventDefault();
        clearCategoryMappings();
    });
    
    // Infinite scroll for mappings
    const mappingsList = document.getElementById('mappings-list');
    mappingsList.addEventListener('scroll', () => {
        if (mappingsState.hasMore && !mappingsState.loading) {
            const scrollHeight = mappingsList.scrollHeight;
            const scrollTop = mappingsList.scrollTop;
            const clientHeight = mappingsList.clientHeight;
            
            if (scrollTop + clientHeight >= scrollHeight - 100) {
                loadMoreMappings();
            }
        }
    });
    
    // SD tab
    document.getElementById('sdSourceSelect').addEventListener('change', loadSdLineups);
    document.getElementById('searchLineupsBtn').addEventListener('click', searchLineups);
    
    // Manual mapping
    document.getElementById('manualMappingEpgSearch').addEventListener('input', debounce(() => searchEpgChannels(true), 300));
    document.getElementById('manualMappingEpgSource').addEventListener('change', () => searchEpgChannels(true));
    document.getElementById('saveManualMappingBtn').addEventListener('click', saveManualMapping);
    setupEpgChannelScroll();
    
    // SD stations search
    document.getElementById('stationSearch').addEventListener('input', debounce(filterStations, 200));
    
    // Tab change handlers
    document.getElementById('channels-tab').addEventListener('shown.bs.tab', loadEpgChannels);
    document.getElementById('mappings-tab').addEventListener('shown.bs.tab', loadMappings);
    document.getElementById('sd-tab').addEventListener('shown.bs.tab', () => {
        loadSdStatus();
        populateSdSourceSelect();
    });
    document.getElementById('xmltv-tab').addEventListener('shown.bs.tab', () => {
        loadXmltvGrabbers();
        loadXmltvConfigs();
    });
});

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// ============================================================================
// Load Data Functions
// ============================================================================

async function loadAccounts() {
    try {
        const response = await fetch('/api/accounts');
        const data = await response.json();
        
        // Check if we got an error response instead of an array
        if (!response.ok || !Array.isArray(data)) {
            console.error('Error loading accounts:', data.error || 'Invalid response');
            return;
        }
        
        accounts = data;
        
        // Populate account selects
        const selects = ['sourceAccountId', 'mappingAccountSelect', 'matchAccountSelect'];
        selects.forEach(id => {
            const select = document.getElementById(id);
            if (select) {
                const firstOption = select.options[0].outerHTML;
                select.innerHTML = firstOption;
                accounts.forEach(a => {
                    select.innerHTML += `<option value="${a.id}">${a.name}</option>`;
                });
            }
        });
    } catch (error) {
        console.error('Error loading accounts:', error);
    }
}

async function loadSources() {
    try {
        const response = await fetch('/api/epg/sources');
        const data = await response.json();
        
        // Check if we got an error response instead of an array
        if (!response.ok || !Array.isArray(data)) {
            throw new Error(data.error || 'Invalid response from server');
        }
        
        sources = data;
        renderSources();
        populateSourceSelects();
    } catch (error) {
        document.getElementById('sources-list').innerHTML = `
            <div class="alert alert-danger">Error loading EPG sources: ${error.message}</div>
        `;
    }
}

function populateSourceSelects() {
    const selects = ['channelSourceSelect', 'matchSourceSelect', 'mappingEpgSourceSelect', 'manualMappingEpgSource'];
    selects.forEach(id => {
        const select = document.getElementById(id);
        if (select) {
            const firstOption = select.options[0].outerHTML;
            select.innerHTML = firstOption;
            sources.forEach(s => {
                select.innerHTML += `<option value="${s.id}">${s.name} (${s.source_type})</option>`;
            });
        }
    });
}

function populateSdSourceSelect() {
    const select = document.getElementById('sdSourceSelect');
    const firstOption = select.options[0].outerHTML;
    select.innerHTML = firstOption;
    sources.filter(s => s.source_type === 'schedules_direct').forEach(s => {
        select.innerHTML += `<option value="${s.id}">${s.name}</option>`;
    });
}

function renderSources() {
    const container = document.getElementById('sources-list');
    
    if (sources.length === 0) {
        container.innerHTML = `
            <div class="alert alert-info">
                <i class="bi bi-info-circle"></i> No EPG sources configured yet.
                Click "Add EPG Source" to get started.
            </div>
        `;
        return;
    }
    
    let html = '<div class="table-responsive"><table class="table table-striped">';
    html += `
        <thead>
            <tr>
                <th>Name</th>
                <th>Type</th>
                <th>Source</th>
                <th>Channels</th>
                <th>In Use</th>
                <th>Last Sync</th>
                <th>Status</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
    `;
    
    for (const source of sources) {
        const statusBadge = source.last_sync_status === 'success' 
            ? '<span class="badge bg-success">Success</span>'
            : source.last_sync_status === 'error'
            ? '<span class="badge bg-danger">Error</span>'
            : '<span class="badge bg-secondary">Never synced</span>';
            
        const sourceInfo = source.source_type === 'provider' 
            ? (source.account_name || 'Account ' + source.account_id)
            : source.source_type === 'xmltv_url'
            ? '<small class="text-muted">' + (source.url?.substring(0, 40) || 'No URL') + '...</small>'
            : source.source_type === 'schedules_direct'
            ? '<i class="bi bi-broadcast-pin"></i> SD'
            : source.source_type === 'xmltv_grabber'
            ? '<i class="bi bi-terminal"></i> ' + (source.xmltv_grabber || 'Grabber')
            : '-';

        // In Use column - clickable if there are mappings
        const usedCount = source.used_mapping_count || 0;
        const inUseHtml = usedCount > 0
            ? `<a href="#" onclick="showSourceMappings(${source.id}, '${source.name.replace(/'/g, "\\'")}'); return false;" class="text-decoration-none">
                <span class="badge bg-primary">${usedCount}</span>
               </a>`
            : '<span class="badge bg-secondary">0</span>';
            
        html += `
            <tr>
                <td>
                    ${source.name}
                    ${!source.enabled ? '<span class="badge bg-secondary ms-2">Disabled</span>' : ''}
                </td>
                <td><span class="badge bg-info">${source.source_type}</span></td>
                <td>${sourceInfo}</td>
                <td>${source.channel_count || 0}</td>
                <td>${inUseHtml}</td>
                <td>${source.last_sync ? new Date(source.last_sync).toLocaleString() : 'Never'}</td>
                <td>${statusBadge}</td>
                <td>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-primary" onclick="syncSource(${source.id})" title="Sync">
                            <i class="bi bi-arrow-repeat"></i>
                        </button>
                        <button class="btn btn-outline-secondary" onclick="editSource(${source.id})" title="Edit">
                            <i class="bi bi-pencil"></i>
                        </button>
                        <button class="btn btn-outline-danger" onclick="deleteSource(${source.id})" title="Delete">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }
    
    html += '</tbody></table></div>';
    container.innerHTML = html;
}

// ============================================================================
// Source CRUD Operations
// ============================================================================

function onSourceTypeChange() {
    const type = document.getElementById('sourceType').value;
    document.getElementById('providerFields').style.display = type === 'provider' ? 'block' : 'none';
    document.getElementById('xmltvFields').style.display = type === 'xmltv_url' ? 'block' : 'none';
    document.getElementById('sdFields').style.display = type === 'schedules_direct' ? 'block' : 'none';
    document.getElementById('grabberFields').style.display = type === 'xmltv_grabber' ? 'block' : 'none';
    
    // Load grabbers list if selecting xmltv_grabber
    if (type === 'xmltv_grabber') {
        populateGrabberSelect();
    }
}

async function saveSource() {
    const id = document.getElementById('sourceId').value;
    const data = {
        name: document.getElementById('sourceName').value,
        source_type: document.getElementById('sourceType').value,
        priority: parseInt(document.getElementById('sourcePriority').value) || 100,
        enabled: document.getElementById('sourceEnabled').checked
    };
    
    // Add type-specific fields
    if (data.source_type === 'provider') {
        data.account_id = parseInt(document.getElementById('sourceAccountId').value);
        if (!data.account_id) {
            alert('Please select an account');
            return;
        }
    } else if (data.source_type === 'xmltv_url') {
        data.url = document.getElementById('sourceUrl').value;
        if (!data.url) {
            alert('Please enter a URL');
            return;
        }
    } else if (data.source_type === 'schedules_direct') {
        data.sd_username = document.getElementById('sdUsername').value;
        data.sd_password = document.getElementById('sdPassword').value;
        if (!data.sd_username || !data.sd_password) {
            alert('Please enter SD credentials');
            return;
        }
    } else if (data.source_type === 'xmltv_grabber') {
        data.xmltv_grabber = document.getElementById('grabberSelect').value;
        data.xmltv_config_name = document.getElementById('grabberConfigName').value || null;
        data.xmltv_days = parseInt(document.getElementById('grabberDays').value) || 7;
        data.xmltv_offset = parseInt(document.getElementById('grabberOffset').value) || 0;
        if (!data.xmltv_grabber) {
            alert('Please select a grabber');
            return;
        }
    }
    
    try {
        const url = id ? `/api/epg/sources/${id}` : '/api/epg/sources';
        const method = id ? 'PUT' : 'POST';
        
        const response = await fetch(url, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            sourceModal.hide();
            await loadSources();
            alert('✓ EPG source saved successfully');
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to save source'));
        }
    } catch (error) {
        alert('Error saving source: ' + error.message);
    }
}

function editSource(id) {
    const source = sources.find(s => s.id === id);
    if (!source) return;
    
    document.getElementById('sourceId').value = source.id;
    document.getElementById('sourceName').value = source.name;
    document.getElementById('sourceType').value = source.source_type;
    document.getElementById('sourcePriority').value = source.priority;
    document.getElementById('sourceEnabled').checked = source.enabled;
    
    if (source.source_type === 'provider') {
        document.getElementById('sourceAccountId').value = source.account_id || '';
    } else if (source.source_type === 'xmltv_url') {
        document.getElementById('sourceUrl').value = source.url || '';
    } else if (source.source_type === 'xmltv_grabber') {
        populateGrabberSelect().then(() => {
            document.getElementById('grabberSelect').value = source.xmltv_grabber || '';
            document.getElementById('grabberConfigName').value = source.xmltv_config_name || '';
            document.getElementById('grabberDays').value = source.xmltv_days || 7;
            document.getElementById('grabberOffset').value = source.xmltv_offset || 0;
        });
    }
    // Note: SD credentials are not pre-filled for security
    
    onSourceTypeChange();
    document.getElementById('sourceModalLabel').textContent = 'Edit EPG Source';
    sourceModal.show();
}

async function deleteSource(id) {
    if (!confirm('Delete this EPG source? This will also delete all its channels.')) return;
    
    try {
        const response = await fetch(`/api/epg/sources/${id}`, { method: 'DELETE' });
        if (response.ok) {
            await loadSources();
            alert('✓ EPG source deleted');
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to delete source'));
        }
    } catch (error) {
        alert('Error deleting source: ' + error.message);
    }
}

async function syncSource(id) {
    const btn = event.target.closest('button');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span>';
    
    try {
        const response = await fetch(`/api/epg/sources/${id}/sync`, { method: 'POST' });
        const result = await response.json();
        
        if (response.ok) {
            await loadSources();
            alert(`✓ Synced! ${result.message}`);
        } else {
            alert('Error: ' + (result.error || 'Sync failed'));
        }
    } catch (error) {
        alert('Error syncing: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

// ============================================================================
// Source Mappings (EPG In-Use Drill-Down)
// ============================================================================

async function showSourceMappings(sourceId, sourceName) {
    currentSourceMappings = {
        sourceId: sourceId,
        sourceName: sourceName,
        offset: 0,
        limit: 50,
        search: ''
    };
    
    document.getElementById('sourceMappingsModalTitle').textContent = `Channels using EPG from: ${sourceName}`;
    document.getElementById('sourceMappingsSearch').value = '';
    
    // Set up search handler
    document.getElementById('sourceMappingsSearch').oninput = debounce(() => {
        currentSourceMappings.search = document.getElementById('sourceMappingsSearch').value;
        currentSourceMappings.offset = 0;
        loadSourceMappingsPage();
    }, 300);
    
    // Set up pagination handlers
    document.getElementById('mappings-prev-btn').onclick = () => {
        if (currentSourceMappings.offset > 0) {
            currentSourceMappings.offset -= currentSourceMappings.limit;
            loadSourceMappingsPage();
        }
    };
    
    document.getElementById('mappings-next-btn').onclick = () => {
        currentSourceMappings.offset += currentSourceMappings.limit;
        loadSourceMappingsPage();
    };
    
    sourceMappingsModal.show();
    await loadSourceMappingsPage();
}

async function loadSourceMappingsPage() {
    const container = document.getElementById('source-mappings-list');
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        let url = `/api/epg/sources/${currentSourceMappings.sourceId}/mappings?limit=${currentSourceMappings.limit}&offset=${currentSourceMappings.offset}`;
        if (currentSourceMappings.search) {
            url += `&search=${encodeURIComponent(currentSourceMappings.search)}`;
        }
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.error || 'Failed to load mappings');
        }
        
        renderSourceMappings(data);
        updateMappingsPagination(data.total, data.offset, data.limit);
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

function renderSourceMappings(data) {
    const container = document.getElementById('source-mappings-list');
    
    if (!data.mappings || data.mappings.length === 0) {
        container.innerHTML = '<div class="alert alert-info">No channels are currently using EPG data from this source.</div>';
        return;
    }
    
    let html = '<div class="table-responsive"><table class="table table-sm table-striped">';
    html += `
        <thead>
            <tr>
                <th style="width: 35%">Channel</th>
                <th style="width: 35%">EPG Channel</th>
                <th>Category</th>
                <th>Match Type</th>
                <th>Confidence</th>
            </tr>
        </thead>
        <tbody>
    `;
    
    for (const m of data.mappings) {
        const confidenceClass = m.confidence >= 0.9 ? 'text-success' : m.confidence >= 0.7 ? 'text-warning' : 'text-danger';
        const confidencePct = Math.round(m.confidence * 100);
        
        const channelIcon = m.channel_icon 
            ? `<img src="${m.channel_icon}" style="max-height: 20px; max-width: 30px; margin-right: 5px;" onerror="this.style.display='none'">`
            : '';
        const epgIcon = m.epg_channel_icon
            ? `<img src="${m.epg_channel_icon}" style="max-height: 20px; max-width: 30px; margin-right: 5px;" onerror="this.style.display='none'">`
            : '';
        
        html += `
            <tr>
                <td>
                    ${channelIcon}
                    <span title="${m.channel_name}">${m.channel_clean_name || m.channel_name}</span>
                </td>
                <td>
                    ${epgIcon}
                    <span title="XMLTV ID: ${m.epg_channel_xmltv_id}">${m.epg_channel_name || m.epg_channel_xmltv_id}</span>
                </td>
                <td><small class="text-muted">${m.category_name || '-'}</small></td>
                <td><span class="badge bg-secondary">${m.mapping_type}</span></td>
                <td><span class="${confidenceClass}">${confidencePct}%</span></td>
            </tr>
        `;
    }
    
    html += '</tbody></table></div>';
    container.innerHTML = html;
}

function updateMappingsPagination(total, offset, limit) {
    const showingText = document.getElementById('mappings-showing-text');
    const prevBtn = document.getElementById('mappings-prev-btn');
    const nextBtn = document.getElementById('mappings-next-btn');
    
    const start = offset + 1;
    const end = Math.min(offset + limit, total);
    showingText.textContent = total > 0 ? `Showing ${start}-${end} of ${total}` : 'No mappings';
    
    prevBtn.disabled = offset === 0;
    nextBtn.disabled = (offset + limit) >= total;
}

// ============================================================================
// EPG Channels
// ============================================================================

// State for EPG channels lazy loading
let epgChannelsState = {
    offset: 0,
    total: 0,
    limit: 100,
    loading: false,
    sourceId: '',
    search: ''
};

async function loadEpgChannels() {
    const sourceId = document.getElementById('channelSourceSelect').value;
    const search = document.getElementById('channelSearch').value;
    const container = document.getElementById('channels-list');
    
    // Reset state for new query
    epgChannelsState = {
        offset: 0,
        total: 0,
        limit: 100,
        loading: false,
        sourceId: sourceId,
        search: search
    };
    
    if (!sourceId && !search) {
        container.innerHTML = '<div class="text-center text-muted py-4">Select a source or search to view EPG channels</div>';
        return;
    }
    
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        let url = `/api/epg/channels?limit=${epgChannelsState.limit}&offset=0`;
        if (sourceId) url += `&source_id=${sourceId}`;
        if (search) url += `&search=${encodeURIComponent(search)}`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.channels.length === 0) {
            container.innerHTML = '<div class="alert alert-info">No EPG channels found</div>';
            return;
        }
        
        epgChannelsState.total = data.total;
        epgChannelsState.offset = data.channels.length;
        
        let html = `<p class="text-muted mb-2" id="epg-channels-count">Showing ${data.channels.length} of ${data.total} channels</p>`;
        html += '<div class="table-responsive" id="epg-channels-table-container" style="max-height: 600px; overflow-y: auto;">';
        html += '<table class="table table-striped table-sm">';
        html += `
            <thead style="position: sticky; top: 0; background: white; z-index: 1;">
                <tr>
                    <th>Channel ID</th>
                    <th>Display Name</th>
                    <th>Icon</th>
                    <th>Programs</th>
                    <th>Mappings</th>
                </tr>
            </thead>
            <tbody id="epg-channels-tbody">
        `;
        
        for (const ch of data.channels) {
            html += renderEpgChannelRow(ch);
        }
        
        html += '</tbody></table>';
        
        // Add loading indicator at bottom
        if (epgChannelsState.offset < epgChannelsState.total) {
            html += '<div id="epg-channels-loader" class="text-center py-3"><div class="spinner-border spinner-border-sm" role="status"></div> Loading more...</div>';
        }
        
        html += '</div>';
        container.innerHTML = html;
        
        // Set up scroll listener for lazy loading
        const tableContainer = document.getElementById('epg-channels-table-container');
        tableContainer.addEventListener('scroll', handleEpgChannelsScroll);
        
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

function renderEpgChannelRow(ch) {
    return `
        <tr>
            <td><code>${ch.channel_id}</code></td>
            <td>${ch.display_name || '-'}</td>
            <td>${ch.icon_url ? `<img src="${ch.icon_url}" style="max-height: 24px;">` : '-'}</td>
            <td>${ch.program_count || 0}</td>
            <td>${ch.mapping_count || 0}</td>
        </tr>
    `;
}

async function handleEpgChannelsScroll(event) {
    const container = event.target;
    const scrollBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
    
    // Load more when within 100px of bottom
    if (scrollBottom < 100 && !epgChannelsState.loading && epgChannelsState.offset < epgChannelsState.total) {
        await loadMoreEpgChannels();
    }
}

async function loadMoreEpgChannels() {
    if (epgChannelsState.loading || epgChannelsState.offset >= epgChannelsState.total) {
        return;
    }
    
    epgChannelsState.loading = true;
    const loader = document.getElementById('epg-channels-loader');
    if (loader) loader.style.display = 'block';
    
    try {
        let url = `/api/epg/channels?limit=${epgChannelsState.limit}&offset=${epgChannelsState.offset}`;
        if (epgChannelsState.sourceId) url += `&source_id=${epgChannelsState.sourceId}`;
        if (epgChannelsState.search) url += `&search=${encodeURIComponent(epgChannelsState.search)}`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.channels.length > 0) {
            const tbody = document.getElementById('epg-channels-tbody');
            let html = '';
            for (const ch of data.channels) {
                html += renderEpgChannelRow(ch);
            }
            tbody.insertAdjacentHTML('beforeend', html);
            
            epgChannelsState.offset += data.channels.length;
            
            // Update count display
            const countEl = document.getElementById('epg-channels-count');
            if (countEl) {
                countEl.textContent = `Showing ${epgChannelsState.offset} of ${epgChannelsState.total} channels`;
            }
        }
        
        // Hide loader if no more data
        if (epgChannelsState.offset >= epgChannelsState.total && loader) {
            loader.style.display = 'none';
        }
        
    } catch (error) {
        console.error('Error loading more EPG channels:', error);
    } finally {
        epgChannelsState.loading = false;
    }
}

// ============================================================================
// Channel Mappings
// ============================================================================

// State for mappings pagination
const mappingsState = {
    offset: 0,
    limit: 100,
    total: 0,
    loading: false,
    hasMore: false,
    accountId: null,
    categoryId: null,
    viewMode: 'all',  // 'all', 'unmapped', 'mapped'
    showFiltered: false
};

// Update auto-match button state based on account selection
function updateAutoMatchButton() {
    const accountId = document.getElementById('mappingAccountSelect').value;
    const btn = document.getElementById('auto-match-btn');
    const dropdown = document.getElementById('auto-match-dropdown');
    const rulesetInfo = document.getElementById('account-ruleset-info');
    
    if (accountId) {
        btn.disabled = false;
        dropdown.disabled = false;
        rulesetInfo.style.display = 'flex';
        loadAccountRulesetInfo(accountId);
    } else {
        btn.disabled = true;
        dropdown.disabled = true;
        rulesetInfo.style.display = 'none';
    }
}

// Load ruleset info for account
async function loadAccountRulesetInfo(accountId) {
    const infoText = document.getElementById('ruleset-info-text');
    try {
        const response = await fetch(`/api/accounts/${accountId}/epg-match-rulesets`);
        const data = await response.json();
        
        // API returns array directly, not {rulesets: [...]}
        if (Array.isArray(data) && data.length > 0) {
            const rulesetNames = data.map(r => r.ruleset_name).join(', ');
            infoText.innerHTML = `<i class="bi bi-list-check text-success"></i> <strong>Rule-based matching enabled:</strong> ${rulesetNames}`;
        } else {
            // Check for default rulesets
            const defaultResponse = await fetch('/api/epg-match-rules/rulesets?is_default=true');
            const defaultData = await defaultResponse.json();
            
            // Default rulesets API also returns array directly
            const defaultRulesets = Array.isArray(defaultData) ? defaultData : (defaultData.rulesets || []);
            if (defaultRulesets.length > 0) {
                const defaultNames = defaultRulesets.map(r => r.name).join(', ');
                infoText.innerHTML = `<i class="bi bi-info-circle"></i> <strong>Using default rulesets:</strong> ${defaultNames}`;
            } else {
                infoText.innerHTML = `<i class="bi bi-exclamation-triangle text-warning"></i> No EPG match rules configured. <a href="/epg-match-rules">Create rules</a> for better matching.`;
            }
        }
    } catch (error) {
        console.error('Error loading ruleset info:', error);
        infoText.innerHTML = `<i class="bi bi-exclamation-circle text-danger"></i> Error loading ruleset info`;
    }
}

async function loadCategoriesForAccount(accountId) {
    const categorySelect = document.getElementById('mappingCategorySelect');
    categorySelect.innerHTML = '<option value="">All Categories</option>';
    
    if (!accountId) {
        return;
    }
    
    try {
        const response = await fetch(`/api/categories?account_id=${accountId}&include_empty=false&include_ppv=false`);
        const categories = await response.json();
        
        for (const cat of categories) {
            const opt = document.createElement('option');
            opt.value = cat.id;
            opt.textContent = `${cat.category_name} (${cat.visible_count} channels)`;
            categorySelect.appendChild(opt);
        }
    } catch (error) {
        console.error('Error loading categories:', error);
    }
}

async function loadMappings(reset = true) {
    const accountId = document.getElementById('mappingAccountSelect').value;
    const categoryId = document.getElementById('mappingCategorySelect').value;
    const viewMode = document.getElementById('mappingViewSelect').value;
    const showFiltered = document.getElementById('showFilteredChannels').checked;
    const container = document.getElementById('mappings-list');
    
    // Update auto-match button state
    updateAutoMatchButton();
    
    if (!accountId) {
        container.innerHTML = '<div class="text-center text-muted py-4">Select an account to view channel mappings</div>';
        document.getElementById('mappingCategorySelect').innerHTML = '<option value="">All Categories</option>';
        return;
    }
    
    // Reset state if filters changed or explicit reset
    if (reset || accountId !== mappingsState.accountId || 
        categoryId !== mappingsState.categoryId ||
        viewMode !== mappingsState.viewMode ||
        showFiltered !== mappingsState.showFiltered) {
        mappingsState.offset = 0;
        mappingsState.accountId = accountId;
        mappingsState.categoryId = categoryId;
        mappingsState.viewMode = viewMode;
        mappingsState.showFiltered = showFiltered;
        container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    }
    
    if (mappingsState.loading) return;
    mappingsState.loading = true;
    
    try {
        let url = `/api/epg/mappings?account_id=${accountId}&view_mode=${viewMode}&show_filtered=${showFiltered}&limit=${mappingsState.limit}&offset=${mappingsState.offset}`;
        if (categoryId) {
            url += `&category_id=${categoryId}`;
        }
        const response = await fetch(url);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
        }
        
        mappingsState.total = data.total;
        mappingsState.hasMore = data.has_more || false;
        
        // Handle empty state
        if (mappingsState.offset === 0 && data.total === 0) {
            let message = 'No channels found with current filters.';
            if (viewMode === 'unmapped') {
                message = '<i class="bi bi-check-circle"></i> All channels have EPG mappings!';
                container.innerHTML = `<div class="alert alert-success">${message}</div>`;
            } else if (viewMode === 'mapped') {
                message = 'No channel mappings found. Run auto-match or create manual mappings.';
                container.innerHTML = `<div class="alert alert-info">${message}</div>`;
            } else {
                container.innerHTML = `<div class="alert alert-info">${message}</div>`;
            }
            return;
        }
        
        // Build table header
        let html = '';
        if (mappingsState.offset === 0) {
            const labelMap = { all: 'channels', unmapped: 'unmapped channels', mapped: 'mapped channels' };
            const filterNote = !showFiltered ? ' (filtered-out channels hidden)' : '';
            html = `<p class="text-muted mb-2" id="mappings-count">Showing 0 of ${data.total} ${labelMap[viewMode] || 'channels'}${filterNote}</p>`;
            html += '<div class="table-responsive" id="mappings-table-container" style="max-height: 600px; overflow-y: auto;">';
            html += '<table class="table table-striped table-sm" id="mappings-table">';
            html += `
                <thead style="position: sticky; top: 0; background: white; z-index: 1;">
                    <tr>
                        <th style="width: 30%">Channel Name</th>
                        <th style="width: 15%">Category</th>
                        <th style="width: 25%">EPG Mapping</th>
                        <th style="width: 15%">Match Info</th>
                        <th style="width: 15%">Actions</th>
                    </tr>
                </thead>
                <tbody id="mappings-tbody">
            `;
        }
        
        // Render rows based on view mode
        const items = data.channels || data.unmapped_channels || data.mappings || [];
        
        for (const item of items) {
            html += renderMappingRow(item, viewMode);
        }
        
        if (mappingsState.offset === 0) {
            html += '</tbody></table>';
            if (data.has_more) {
                html += '<div id="mappings-loader" class="text-center py-3"><div class="spinner-border spinner-border-sm"></div> Loading more...</div>';
            }
            html += '</div>';
            container.innerHTML = html;
            
            // Set up scroll listener for lazy loading
            const tableContainer = document.getElementById('mappings-table-container');
            if (tableContainer) {
                tableContainer.addEventListener('scroll', handleMappingsScroll);
            }
        } else {
            document.getElementById('mappings-tbody').insertAdjacentHTML('beforeend', html);
        }
        
        // Update offset for next load
        mappingsState.offset += items.length;
        
        // Update count display
        const countEl = document.getElementById('mappings-count');
        if (countEl) {
            const labelMap = { all: 'channels', unmapped: 'unmapped channels', mapped: 'mapped channels' };
            const filterNote = !showFiltered ? ' (filtered-out channels hidden)' : '';
            countEl.textContent = `Showing ${mappingsState.offset} of ${mappingsState.total} ${labelMap[viewMode] || 'channels'}${filterNote}`;
        }
        
        // Show/hide loader based on whether there's more data
        const loader = document.getElementById('mappings-loader');
        if (loader) {
            loader.style.display = mappingsState.hasMore ? 'block' : 'none';
        }
        
    } catch (error) {
        if (mappingsState.offset === 0) {
            container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
        }
        console.error('Error loading mappings:', error);
    } finally {
        mappingsState.loading = false;
    }
}

// Render a single row in the mappings table
function renderMappingRow(item, viewMode) {
    const filteredBadge = item.is_visible === false ? '<span class="badge bg-secondary ms-1">Filtered</span>' : '';
    
    // Determine channel info and mapping info based on view mode
    let channelId, channelName, originalName, streamId, accountId, categoryName, mapping;
    
    if (viewMode === 'all') {
        // item is a channel with optional mapping
        channelId = item.id;
        originalName = item.name;
        channelName = item.cleaned_name || item.name;
        streamId = item.stream_id;
        accountId = item.account_id;
        categoryName = item.category_name || '-';
        mapping = item.mapping;
    } else if (viewMode === 'unmapped') {
        // item is an unmapped channel
        channelId = item.id;
        originalName = item.name;
        channelName = item.cleaned_name || item.name;
        streamId = item.stream_id;
        accountId = item.account_id;
        categoryName = item.category_name || '-';
        mapping = null;
    } else {
        // viewMode === 'mapped' - item is a mapping
        channelId = item.channel_id;
        originalName = item.channel_name;
        channelName = item.cleaned_name || item.channel_name || `Channel #${item.channel_id}`;
        streamId = item.stream_id;
        accountId = item.account_id;
        categoryName = '-';
        mapping = {
            id: item.id,
            epg_display_name: item.epg_display_name,
            mapping_type: item.mapping_type,
            confidence: item.confidence,
            is_override: item.is_override
        };
    }
    
    // Build mapping info cell
    let mappingCell, matchInfoCell;
    if (mapping) {
        mappingCell = `<span class="text-success">${mapping.epg_display_name || 'EPG #' + mapping.epg_channel_id}</span>`;
        
        const typeBadge = mapping.mapping_type === 'manual' 
            ? '<span class="badge bg-primary">Manual</span>'
            : mapping.mapping_type === 'provider'
            ? '<span class="badge bg-success">Provider</span>'
            : mapping.mapping_type === 'callsign_tag'
            ? '<span class="badge bg-info">Callsign</span>'
            : mapping.mapping_type === 'fcc_lookup'
            ? '<span class="badge bg-info">FCC</span>'
            : mapping.mapping_type?.includes('auto')
            ? '<span class="badge bg-info">Auto</span>'
            : `<span class="badge bg-secondary">${mapping.mapping_type || 'Unknown'}</span>`;
        
        const confidencePercent = Math.round((mapping.confidence || 0) * 100);
        const overrideIcon = mapping.is_override ? ' <i class="bi bi-pin-fill text-warning" title="Override"></i>' : '';
        
        matchInfoCell = `${typeBadge} ${confidencePercent}%${overrideIcon}`;
    } else {
        mappingCell = '<span class="text-muted">Not mapped</span>';
        matchInfoCell = '-';
    }
    
    // Build actions
    let actions = `<a class="btn btn-outline-success btn-sm" href="/stream/${accountId}/${streamId}.ts" target="_blank" title="Play stream"><i class="bi bi-play-fill"></i></a>`;
    
    if (mapping) {
        actions += ` <button class="btn btn-outline-danger btn-sm" onclick="deleteMapping(${mapping.id}, ${channelId})" title="Delete mapping"><i class="bi bi-trash"></i></button>`;
    } else {
        actions += ` <button class="btn btn-outline-primary btn-sm" onclick="showManualMappingModal(${channelId}, '${escapeHtml(channelName)}')" title="Create mapping"><i class="bi bi-link"></i></button>`;
    }
    
    // Add hide channel button
    const escapedChannelName = escapeHtml(channelName).replace(/'/g, "\\'");
    actions += ` <button class="btn btn-outline-secondary btn-sm" onclick="hideChannel(${accountId}, '${escapedChannelName}')" title="Hide this channel"><i class="bi bi-eye-slash"></i></button>`;
    
    // Show original name as tooltip if it differs from cleaned name
    const tooltip = originalName && originalName !== channelName ? ` title="${escapeHtml(originalName)}"` : '';
    
    return `
        <tr data-channel-id="${channelId}">
            <td${tooltip}>${channelName}${filteredBadge}</td>
            <td><small class="text-muted">${categoryName}</small></td>
            <td>${mappingCell}</td>
            <td>${matchInfoCell}</td>
            <td><div class="btn-group btn-group-sm">${actions}</div></td>
        </tr>
    `;
}

async function handleMappingsScroll(event) {
    const container = event.target;
    const scrollBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
    
    // Load more when within 100px of bottom
    if (scrollBottom < 100 && !mappingsState.loading && mappingsState.hasMore) {
        await loadMoreMappings();
    }
}

async function loadMoreMappings() {
    if (!mappingsState.hasMore || mappingsState.loading) return;
    
    const loader = document.getElementById('mappings-loader');
    if (loader) loader.style.display = 'block';
    
    await loadMappings(false);
}

async function deleteMapping(id, channelId) {
    try {
        const response = await fetch(`/api/epg/mappings/${id}`, { method: 'DELETE' });
        if (response.ok) {
            // Update the row in place instead of reloading the entire list
            const row = document.querySelector(`tr[data-channel-id="${channelId}"]`);
            if (row) {
                // Update mapping cell to show "Not mapped"
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    cells[2].innerHTML = '<span class="text-muted">Not mapped</span>';
                    cells[3].innerHTML = '-';
                }
                // Update actions - replace delete button with create mapping button
                const channelName = cells[0].textContent.replace(/Filtered$/, '').trim();
                const actionsDiv = cells[4].querySelector('.btn-group');
                if (actionsDiv) {
                    const deleteBtn = actionsDiv.querySelector('button[onclick^="deleteMapping"]');
                    if (deleteBtn) {
                        const createBtn = document.createElement('button');
                        createBtn.className = 'btn btn-outline-primary btn-sm';
                        createBtn.setAttribute('onclick', `showManualMappingModal(${channelId}, '${escapeHtml(channelName)}')`);
                        createBtn.setAttribute('title', 'Create mapping');
                        createBtn.innerHTML = '<i class="bi bi-link"></i>';
                        deleteBtn.replaceWith(createBtn);
                    }
                }
            }
            showToast('Mapping deleted', 'success');
        } else {
            const error = await response.json();
            showToast('Error: ' + (error.error || 'Failed to delete mapping'), 'error');
        }
    } catch (error) {
        showToast('Error: ' + error.message, 'error');
    }
}

async function clearCategoryMappings() {
    const accountId = document.getElementById('mappingAccountSelect').value;
    const categoryId = document.getElementById('mappingCategorySelect').value;
    const categorySelect = document.getElementById('mappingCategorySelect');
    const categoryName = categorySelect.options[categorySelect.selectedIndex]?.text || 'selected category';
    
    if (!accountId) {
        alert('Please select an account first');
        return;
    }
    
    if (!categoryId) {
        alert('Please select a category first');
        return;
    }
    
    if (!confirm(`Are you sure you want to delete ALL EPG mappings for channels in "${categoryName}"?\n\nThis action cannot be undone.`)) {
        return;
    }
    
    try {
        const response = await fetch('/api/epg/mappings/bulk-delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ account_id: parseInt(accountId), category_id: parseInt(categoryId) })
        });
        
        const result = await response.json();
        
        if (response.ok) {
            showToast(`Deleted ${result.deleted_count} mappings from "${categoryName}"`, 'success');
            await loadMappings();
        } else {
            showToast('Error: ' + (result.error || 'Failed to delete mappings'), 'error');
        }
    } catch (error) {
        showToast('Error: ' + error.message, 'error');
    }
}

async function runAutoMatch() {
    console.log('runAutoMatch called');
    const accountId = document.getElementById('mappingAccountSelect').value;
    const categoryId = document.getElementById('mappingCategorySelect').value;
    const includeFiltered = document.getElementById('showFilteredChannels').checked;
    const sourceId = document.getElementById('mappingEpgSourceSelect').value;
    
    console.log('Account ID:', accountId, 'Category ID:', categoryId, 'Source ID:', sourceId);
    
    if (!accountId) {
        alert('Please select an account');
        return;
    }
    
    const btn = document.getElementById('auto-match-btn');
    const dropdown = document.getElementById('auto-match-dropdown');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    dropdown.disabled = true;
    btn.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Matching...`;
    
    // Show progress in the list area itself
    const listContainer = document.getElementById('mappings-list');
    const originalListContent = listContainer.innerHTML;
    
    // Hide the results alert initially
    const alertDiv = document.getElementById('autoMatchResultsAlert');
    alertDiv.classList.add('d-none');
    
    try {
        await runRuleBasedMatch(accountId, categoryId, includeFiltered, sourceId, listContainer, alertDiv);
        
        console.log('Reloading mappings...');
        // Reload the mappings list to show updated results
        await loadMappings();
    } catch (error) {
        console.error('Error in runAutoMatch:', error);
        // Restore original content on error
        listContainer.innerHTML = originalListContent;
        alertDiv.classList.remove('d-none', 'alert-info', 'alert-success');
        alertDiv.classList.add('alert-danger');
        const contentDiv = document.getElementById('autoMatchResultsContent');
        
        // Provide more helpful error messages
        let errorMsg = error.message;
        if (error.name === 'AbortError') {
            errorMsg = 'Operation timed out after 10 minutes. Try filtering by category to match fewer channels at once.';
        } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
            errorMsg = 'Network error or server timeout. For large channel lists, try filtering by category first.';
        }
        
        contentDiv.innerHTML = `<strong><i class="bi bi-x-circle"></i> Error:</strong> ${errorMsg}`;
    } finally {
        btn.disabled = false;
        dropdown.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

// Rule-based matching function
async function runRuleBasedMatch(accountId, categoryId, includeFiltered, sourceId, listContainer, alertDiv) {
    listContainer.innerHTML = `
        <div class="text-center py-5">
            <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;"></div>
            <h5>Running Rule-Based Match...</h5>
            <p class="text-muted">Matching channels using configured EPG match rules.</p>
        </div>
    `;
    
    let url = `/api/epg/match-with-rules/${accountId}?`;
    const params = [];
    if (categoryId) params.push(`category_id=${categoryId}`);
    if (includeFiltered) params.push('include_filtered=true');
    if (sourceId) params.push(`source_id=${sourceId}`);
    url += params.join('&');
    
    const response = await fetch(url, { method: 'POST' });
    const result = await response.json();
    
    if (!response.ok) {
        throw new Error(result.error || 'Rule-based match failed');
    }
    
    const stats = result.stats || {};
    const matchedCount = stats.matched || 0;
    
    alertDiv.classList.remove('d-none', 'alert-info', 'alert-danger');
    alertDiv.classList.add('alert-success');
    const contentDiv = document.getElementById('autoMatchResultsContent');
    
    // Build detailed stats display
    let statsHtml = `<i class="bi bi-check-circle"></i> <strong>Rule-Based Match: ${matchedCount} channels matched</strong>`;
    
    // Show match type breakdown if available
    const byType = stats.by_match_type || {};
    const typeDetails = [];
    if (byType.exact_id) typeDetails.push(`ID: ${byType.exact_id}`);
    if (byType.callsign_tag) typeDetails.push(`Callsign: ${byType.callsign_tag}`);
    if (byType.fcc_lookup) typeDetails.push(`FCC: ${byType.fcc_lookup}`);
    if (byType.exact_name) typeDetails.push(`Name: ${byType.exact_name}`);
    if (byType.fuzzy_name) typeDetails.push(`Fuzzy: ${byType.fuzzy_name}`);
    if (byType.regex) typeDetails.push(`Regex: ${byType.regex}`);
    
    if (typeDetails.length > 0) {
        statsHtml += ` <span class="ms-2 text-muted small">(${typeDetails.join(', ')}`;
        if (stats.skipped_existing) statsHtml += `, Skipped: ${stats.skipped_existing}`;
        if (stats.excluded) statsHtml += `, Excluded: ${stats.excluded}`;
        if (stats.unmatched) statsHtml += `, Unmatched: ${stats.unmatched}`;
        statsHtml += `)</span>`;
    }
    
    contentDiv.innerHTML = statsHtml;
}

function showManualMappingModal(channelId, channelName) {
    document.getElementById('manualMappingChannelId').value = channelId;
    document.getElementById('manualMappingChannel').textContent = channelName;
    document.getElementById('manualMappingEpgSearch').value = '';
    document.getElementById('manualMappingEpgChannel').value = '';
    document.getElementById('epgChannelList').innerHTML = '<div class="list-group-item text-muted">Type to search EPG channels...</div>';
    document.getElementById('manualMappingTimeOffset').value = '0';
    document.getElementById('selectedEpgChannel').style.display = 'none';
    // Reset lazy load state
    epgSearchState = { search: '', offset: 0, hasMore: true, loading: false };
    manualMappingModal.show();
}

// State for EPG channel lazy loading in manual mapping modal
let epgSearchState = { search: '', offset: 0, hasMore: true, loading: false };
const EPG_CHANNELS_PER_PAGE = 20;

function clearSelectedEpgChannel() {
    document.getElementById('manualMappingEpgChannel').value = '';
    document.getElementById('selectedEpgChannel').style.display = 'none';
    // Re-highlight list items
    document.querySelectorAll('#epgChannelList .list-group-item').forEach(item => {
        item.classList.remove('active');
    });
}

function selectEpgChannel(id, displayName, channelId) {
    document.getElementById('manualMappingEpgChannel').value = id;
    document.getElementById('selectedEpgChannelName').textContent = `${displayName} (${channelId})`;
    document.getElementById('selectedEpgChannel').style.display = 'block';
    // Highlight selected item
    document.querySelectorAll('#epgChannelList .list-group-item').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.id === String(id)) {
            item.classList.add('active');
        }
    });
}

async function searchEpgChannels(resetResults = true) {
    const search = document.getElementById('manualMappingEpgSearch').value.trim();
    const sourceId = document.getElementById('manualMappingEpgSource').value;
    
    if (resetResults) {
        epgSearchState = { search: search, offset: 0, hasMore: true, loading: false };
        document.getElementById('epgChannelList').innerHTML = '';
        // Clear selection when search changes
        document.getElementById('manualMappingEpgChannel').value = '';
        document.getElementById('selectedEpgChannel').style.display = 'none';
    }
    
    if (search.length < 2) {
        document.getElementById('epgChannelList').innerHTML = '<div class="list-group-item text-muted">Type at least 2 characters to search...</div>';
        return;
    }
    
    if (epgSearchState.loading || !epgSearchState.hasMore) return;
    
    epgSearchState.loading = true;
    const loader = document.getElementById('epgChannelLoader');
    loader.style.display = 'block';
    
    try {
        let url = `/api/epg/channels?search=${encodeURIComponent(search)}&limit=${EPG_CHANNELS_PER_PAGE}&offset=${epgSearchState.offset}`;
        if (sourceId) url += `&source_id=${sourceId}`;
        const response = await fetch(url);
        const data = await response.json();
        
        const list = document.getElementById('epgChannelList');
        
        if (data.channels.length === 0 && epgSearchState.offset === 0) {
            list.innerHTML = '<div class="list-group-item text-muted">No channels found. Try different search terms.</div>';
            epgSearchState.hasMore = false;
            loader.style.display = 'none';
            epgSearchState.loading = false;
            return;
        }
        
        // Append channels to list
        data.channels.forEach(ch => {
            const item = document.createElement('button');
            item.type = 'button';
            item.className = 'list-group-item list-group-item-action';
            item.dataset.id = ch.id;
            item.innerHTML = `
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${escapeHtml(ch.display_name)}</strong>
                        <small class="text-muted ms-2">(${escapeHtml(ch.channel_id)})</small>
                    </div>
                    <small class="text-muted">${ch.program_count || 0} programs</small>
                </div>
            `;
            item.onclick = () => selectEpgChannel(ch.id, ch.display_name, ch.channel_id);
            list.appendChild(item);
        });
        
        epgSearchState.offset += data.channels.length;
        epgSearchState.hasMore = epgSearchState.offset < data.total;
        
    } catch (error) {
        console.error('Error searching EPG channels:', error);
        document.getElementById('epgChannelList').innerHTML = '<div class="list-group-item text-danger">Error loading channels</div>';
    } finally {
        loader.style.display = 'none';
        epgSearchState.loading = false;
    }
}

// Set up scroll handler for lazy loading EPG channels
function setupEpgChannelScroll() {
    const container = document.getElementById('epgChannelListContainer');
    if (container) {
        container.addEventListener('scroll', () => {
            const scrollBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
            if (scrollBottom < 50 && epgSearchState.hasMore && !epgSearchState.loading) {
                searchEpgChannels(false);
            }
        });
    }
}

async function saveManualMapping() {
    const channelId = document.getElementById('manualMappingChannelId').value;
    const epgChannelId = document.getElementById('manualMappingEpgChannel').value;
    const timeOffset = parseInt(document.getElementById('manualMappingTimeOffset').value) || 0;
    
    if (!channelId || !epgChannelId) {
        alert('Please select an EPG channel');
        return;
    }
    
    try {
        const response = await fetch('/api/epg/mappings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                channel_id: parseInt(channelId),
                epg_channel_id: parseInt(epgChannelId),
                time_offset_hours: timeOffset
            })
        });
        
        if (response.ok) {
            const mapping = await response.json();
            manualMappingModal.hide();
            
            // Update the row in place instead of reloading
            const row = document.querySelector(`tr[data-channel-id="${channelId}"]`);
            if (row) {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 4) {
                    // Update mapping cell
                    cells[2].innerHTML = `<span class="text-success">${mapping.epg_display_name || 'EPG #' + epgChannelId}</span>`;
                    // Update match info cell
                    cells[3].innerHTML = '<span class="badge bg-primary">Manual</span> 100%';
                }
                // Update actions - replace create mapping button with delete button
                const actionsDiv = cells[4].querySelector('.btn-group');
                if (actionsDiv) {
                    const createBtn = actionsDiv.querySelector('button[onclick^="showManualMappingModal"]');
                    if (createBtn) {
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'btn btn-outline-danger btn-sm';
                        deleteBtn.setAttribute('onclick', `deleteMapping(${mapping.id}, ${channelId})`);
                        deleteBtn.setAttribute('title', 'Delete mapping');
                        deleteBtn.innerHTML = '<i class="bi bi-trash"></i>';
                        createBtn.replaceWith(deleteBtn);
                    }
                }
            }
            showToast('Mapping created', 'success');
        } else {
            const error = await response.json();
            showToast('Error: ' + (error.error || 'Failed to create mapping'), 'error');
        }
    } catch (error) {
        showToast('Error: ' + error.message, 'error');
    }
}

// ============================================================================
// Coverage Stats
// ============================================================================

async function loadCoverage() {
    const container = document.getElementById('coverage-summary');
    const content = document.getElementById('coverage-content');
    container.style.display = 'block';
    content.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        const response = await fetch('/api/epg/coverage');
        const stats = await response.json();
        
        const coveragePercent = stats.total_channels > 0 
            ? ((stats.channels_with_epg_mapping / stats.total_channels) * 100).toFixed(1)
            : 0;
            
        content.innerHTML = `
            <div class="row">
                <div class="col-md-3 text-center">
                    <h3 class="text-primary">${stats.total_channels}</h3>
                    <small>Total Channels</small>
                </div>
                <div class="col-md-3 text-center">
                    <h3 class="text-success">${stats.channels_with_epg_mapping}</h3>
                    <small>With EPG Mapping</small>
                </div>
                <div class="col-md-3 text-center">
                    <h3 class="text-info">${stats.epg_sources}</h3>
                    <small>EPG Sources</small>
                </div>
                <div class="col-md-3 text-center">
                    <h3 class="text-warning">${coveragePercent}%</h3>
                    <small>Coverage</small>
                </div>
            </div>
            <div class="progress mt-3" style="height: 25px;">
                <div class="progress-bar bg-success" style="width: ${coveragePercent}%">${coveragePercent}% covered</div>
            </div>
        `;
    } catch (error) {
        content.innerHTML = `<div class="alert alert-danger">Error loading coverage: ${error.message}</div>`;
    }
}

// ============================================================================
// Schedules Direct Functions
// ============================================================================

async function loadSdStatus() {
    const container = document.getElementById('sd-status-content');
    
    try {
        const response = await fetch('/api/epg/sd/status');
        const status = await response.json();
        
        if (status.status === 'online') {
            container.innerHTML = `
                <div class="alert alert-success mb-0">
                    <i class="bi bi-check-circle-fill"></i> Service is <strong>Online</strong>
                    <br><small>Message: ${status.message || 'All systems operational'}</small>
                </div>
            `;
        } else {
            container.innerHTML = `
                <div class="alert alert-warning mb-0">
                    <i class="bi bi-exclamation-triangle-fill"></i> Service status: <strong>${status.status || 'Unknown'}</strong>
                    <br><small>${status.message || ''}</small>
                </div>
            `;
        }
    } catch (error) {
        container.innerHTML = `
            <div class="alert alert-secondary mb-0">
                <i class="bi bi-question-circle"></i> Could not check SD status: ${error.message}
            </div>
        `;
    }
}

async function testSdCredentials() {
    const username = document.getElementById('sdUsername').value;
    const password = document.getElementById('sdPassword').value;
    const resultDiv = document.getElementById('sdCredentialsResult');
    
    if (!username || !password) {
        alert('Please enter credentials first');
        return;
    }
    
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = '<div class="alert alert-secondary"><span class="spinner-border spinner-border-sm"></span> Testing...</div>';
    
    try {
        const response = await fetch('/api/epg/sd/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
        });
        
        const result = await response.json();
        
        if (result.success) {
            resultDiv.innerHTML = `
                <div class="alert alert-success">
                    <i class="bi bi-check-circle"></i> Credentials valid!
                    ${result.account_info ? `<br><small>Account: ${JSON.stringify(result.account_info)}</small>` : ''}
                </div>
            `;
        } else {
            resultDiv.innerHTML = `<div class="alert alert-danger"><i class="bi bi-x-circle"></i> ${result.error || 'Invalid credentials'}</div>`;
        }
    } catch (error) {
        resultDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function loadSdLineups() {
    const sourceId = document.getElementById('sdSourceSelect').value;
    const container = document.getElementById('sd-lineups-list');
    const searchBtn = document.getElementById('searchLineupsModalBtn');
    
    if (!sourceId) {
        searchBtn.disabled = true;
        searchBtn.title = 'Select a Schedules Direct source first';
        container.innerHTML = '<div class="text-center text-muted py-3">Select a Schedules Direct source to view lineups</div>';
        return;
    }
    
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        const response = await fetch(`/api/epg/sd/lineups?source_id=${sourceId}`);
        const result = await response.json();
        
        // Check if response is an error
        if (result.error || result.success === false) {
            container.innerHTML = `<div class="alert alert-danger">${result.error || 'Failed to load lineups'}</div>`;
            searchBtn.disabled = true;
            return;
        }
        
        // New response format has lineups array and limit info
        const lineups = result.lineups || [];
        const accountLineups = result.account_lineups || 0;
        const maxLineups = result.max_lineups || 4;
        const atLimit = accountLineups >= maxLineups;
        
        // Update search button based on lineup limit
        if (atLimit) {
            searchBtn.disabled = true;
            searchBtn.title = `Lineup limit reached (${accountLineups}/${maxLineups}). Remove a lineup to add more.`;
        } else {
            searchBtn.disabled = false;
            searchBtn.title = `Search for lineups to add (${accountLineups}/${maxLineups} used)`;
        }
        
        // Build lineup status header
        let html = `
            <div class="alert ${atLimit ? 'alert-warning' : 'alert-info'} mb-3">
                <i class="bi bi-${atLimit ? 'exclamation-triangle' : 'info-circle'}"></i>
                <strong>SD Account Lineups:</strong> ${accountLineups} of ${maxLineups} used
                ${atLimit ? '<br><small>Remove a lineup from your SD account to add more.</small>' : ''}
            </div>
        `;
        
        if (lineups.length === 0) {
            if (atLimit) {
                html += `
                    <div class="alert alert-secondary">
                        No lineups added to this source yet. Your SD account has ${accountLineups} lineup(s) 
                        that may be added to other sources or managed via schedulesdirect.org.
                    </div>
                `;
            } else {
                html += `
                    <div class="alert alert-secondary">
                        No lineups added yet. Use "Search Lineups" to find and add lineups for your area.
                    </div>
                `;
            }
            container.innerHTML = html;
            return;
        }
        
        html += '<div class="list-group">';
        for (const lineup of lineups) {
            html += `
                <div class="list-group-item">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong>${lineup.name || lineup.lineup_id}</strong>
                            <br><small class="text-muted">${lineup.location || ''} - ${lineup.lineup_type || ''}</small>
                            <br><small>${lineup.channel_count} channels</small>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-primary" onclick="viewStations(${lineup.id}, '${escapeHtml(lineup.name || lineup.lineup_id)}')">
                                <i class="bi bi-list"></i> Stations
                            </button>
                            <button class="btn btn-outline-success" onclick="syncSdLineup(${lineup.id})">
                                <i class="bi bi-arrow-repeat"></i> Sync
                            </button>
                            <button class="btn btn-outline-danger" onclick="removeSdLineup(${lineup.id})">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        html += '</div>';
        container.innerHTML = html;
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function searchLineups() {
    const sourceId = document.getElementById('sdSourceSelect').value;
    if (!sourceId) {
        alert('Please select a Schedules Direct source first');
        return;
    }
    
    const country = document.getElementById('searchCountry').value;
    const postalcode = document.getElementById('searchPostalCode').value;
    const container = document.getElementById('lineupSearchResults');
    
    if (!postalcode) {
        alert('Please enter a postal code');
        return;
    }
    
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/search?source_id=${sourceId}&country=${country}&postalcode=${postalcode}`);
        const result = await response.json();
        
        if (!result.success) {
            container.innerHTML = `<div class="alert alert-danger">${result.error || 'Search failed'}</div>`;
            return;
        }
        
        const lineups = Array.isArray(result.lineups) ? result.lineups : [];
        
        if (lineups.length === 0) {
            container.innerHTML = '<div class="alert alert-info">No lineups found for this location</div>';
            return;
        }
        
        let html = '<div class="list-group">';
        for (const lineup of lineups) {
            html += `
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${lineup.name || lineup.lineup}</strong>
                        <br><small class="text-muted">${lineup.location || ''}</small>
                        <br><small>Type: ${lineup.type || lineup.transport || '-'}</small>
                    </div>
                    <button class="btn btn-sm btn-primary" onclick="addSdLineup('${lineup.lineup}', '${escapeHtml(lineup.name || '')}', '${escapeHtml(lineup.location || '')}', '${lineup.type || lineup.transport || ''}')">
                        <i class="bi bi-plus"></i> Add
                    </button>
                </div>
            `;
        }
        html += '</div>';
        container.innerHTML = html;
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function addSdLineup(lineupId, name, location, type) {
    const sourceId = document.getElementById('sdSourceSelect').value;
    
    try {
        const response = await fetch('/api/epg/sd/lineups?sync=true', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                source_id: parseInt(sourceId),
                lineup_id: lineupId,
                name: name,
                location: location,
                lineup_type: type
            })
        });
        
        const result = await response.json();
        
        if (response.ok) {
            searchLineupModal.hide();
            loadSdLineups();
            alert(`✓ Lineup added! ${result.message}`);
        } else {
            // Check for lineup limit error
            if (result.limit_reached) {
                alert(`⚠️ Lineup limit reached!\n\nYour Schedules Direct account allows a maximum of ${result.max_lineups} lineups.\n\nYou currently have ${result.current_count} lineup(s). Please remove a lineup before adding a new one.`);
            } else {
                alert('Error: ' + (result.error || 'Failed to add lineup'));
            }
            // Refresh to update the limit display
            loadSdLineups();
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function syncSdLineup(lineupId) {
    const btn = event.target.closest('button');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/${lineupId}/sync`, { method: 'POST' });
        const result = await response.json();
        
        if (response.ok) {
            loadSdLineups();
            alert(`✓ Synced ${result.channels_synced || 0} channels`);
        } else {
            alert('Error: ' + (result.error || 'Sync failed'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

async function removeSdLineup(lineupId) {
    if (!confirm('Remove this lineup and all its stations?')) return;
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/${lineupId}`, { method: 'DELETE' });
        if (response.ok) {
            loadSdLineups();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to remove lineup'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

let currentStations = [];

async function viewStations(lineupId, lineupName) {
    document.getElementById('sdStationsModalTitle').textContent = `Stations: ${lineupName}`;
    document.getElementById('stationSearch').value = '';
    const container = document.getElementById('sd-stations-list');
    container.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
    sdStationsModal.show();
    
    try {
        const response = await fetch(`/api/epg/sd/lineups/${lineupId}/stations`);
        const data = await response.json();
        currentStations = data.stations || [];
        renderStations(currentStations);
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

function filterStations() {
    const search = document.getElementById('stationSearch').value.toLowerCase();
    const filtered = currentStations.filter(s => 
        (s.callsign || '').toLowerCase().includes(search) ||
        (s.name || '').toLowerCase().includes(search) ||
        (s.channel_number || '').toString().includes(search)
    );
    renderStations(filtered);
}

function renderStations(stations) {
    const container = document.getElementById('sd-stations-list');
    
    if (stations.length === 0) {
        container.innerHTML = '<div class="text-center text-muted py-3">No stations found</div>';
        return;
    }
    
    let html = '<table class="table table-striped table-sm"><thead><tr>';
    html += '<th>Ch #</th><th>Callsign</th><th>Name</th><th>Affiliate</th><th>Logo</th>';
    html += '</tr></thead><tbody>';
    
    for (const s of stations) {
        html += `
            <tr>
                <td>${s.channel_number || '-'}</td>
                <td><strong>${s.callsign || '-'}</strong></td>
                <td>${s.name || '-'}</td>
                <td>${s.affiliate || '-'}</td>
                <td>${s.logo_url ? `<img src="${s.logo_url}" style="max-height: 24px;">` : '-'}</td>
            </tr>
        `;
    }
    
    html += '</tbody></table>';
    container.innerHTML = html;
}

// ============================================================================
// Utility Functions
// ============================================================================

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showToast(message, type = 'success') {
    // Create toast container if it doesn't exist
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
        toastContainer.style.zIndex = '1050';
        document.body.appendChild(toastContainer);
    }
    
    const toastId = 'toast-' + Date.now();
    const bgClass = type === 'success' ? 'bg-success' : type === 'error' ? 'bg-danger' : 'bg-info';
    
    const toastHtml = `
        <div id="${toastId}" class="toast align-items-center text-white ${bgClass} border-0" role="alert">
            <div class="d-flex">
                <div class="toast-body">${message}</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
            </div>
        </div>
    `;
    
    toastContainer.insertAdjacentHTML('beforeend', toastHtml);
    const toastElement = document.getElementById(toastId);
    const toast = new bootstrap.Toast(toastElement);
    toast.show();
    
    // Remove from DOM after hidden
    toastElement.addEventListener('hidden.bs.toast', () => toastElement.remove());
}

async function hideChannel(accountId, channelName) {    
    try {
        const response = await fetch('/api/filters', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                account_id: accountId,
                name: `Hide: ${channelName}`,
                filter_type: 'channel_name',
                filter_action: 'blacklist',
                filter_value: channelName,
                enabled: true
            })
        });
        
        if (response.ok) {
            showToast(`Channel "${channelName}" hidden`, 'success');
            // Find and update the row to show filtered badge, or remove it
            const rows = document.querySelectorAll('#mappings-list tbody tr');
            for (const row of rows) {
                const nameCell = row.querySelector('td:first-child');
                if (nameCell && nameCell.textContent.trim().replace(/Filtered$/, '').trim() === channelName) {
                    // Add filtered badge if not already present
                    if (!nameCell.querySelector('.badge')) {
                        nameCell.innerHTML += '<span class="badge bg-secondary ms-1">Filtered</span>';
                    }
                    // Optionally fade the row to indicate it's filtered
                    row.style.opacity = '0.5';
                    break;
                }
            }
        } else {
            const error = await response.json();
            showToast('Error: ' + (error.error || 'Failed to hide channel'), 'error');
        }
    } catch (error) {
        showToast('Error: ' + error.message, 'error');
    }
}

// ============================================================================
// XMLTV Grabbers
// ============================================================================

let xmltvGrabbers = [];

async function loadXmltvGrabbers() {
    const container = document.getElementById('xmltv-grabbers-list');
    
    try {
        const response = await fetch('/api/xmltv/grabbers');
        xmltvGrabbers = await response.json();
        
        if (xmltvGrabbers.length === 0) {
            container.innerHTML = `
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle"></i> No XMLTV grabbers found.
                    <p class="small mb-0 mt-2">Make sure the XMLTV utilities are installed in the Docker container.</p>
                </div>
            `;
            return;
        }
        
        let html = '<div class="table-responsive"><table class="table table-striped table-sm">';
        html += '<thead><tr><th>Grabber</th><th>Description</th><th>Capabilities</th><th>Actions</th></tr></thead><tbody>';
        
        for (const grabber of xmltvGrabbers) {
            const caps = (grabber.capabilities || []).slice(0, 3).join(', ');
            html += `
                <tr>
                    <td><code>${grabber.name}</code></td>
                    <td>${grabber.description || '-'}</td>
                    <td><small class="text-muted">${caps}</small></td>
                    <td>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-info" onclick="viewGrabberChannels('${grabber.name}')" title="List Channels">
                                <i class="bi bi-list"></i>
                            </button>
                            <button class="btn btn-outline-primary" onclick="quickCreateGrabberSource('${grabber.name}')" title="Create Source">
                                <i class="bi bi-plus"></i>
                            </button>
                        </div>
                    </td>
                </tr>
            `;
        }
        
        html += '</tbody></table></div>';
        container.innerHTML = html;
        
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error loading grabbers: ${error.message}</div>`;
    }
}

async function populateGrabberSelect() {
    const select = document.getElementById('grabberSelect');
    
    // Only fetch if not already loaded
    if (xmltvGrabbers.length === 0) {
        try {
            const response = await fetch('/api/xmltv/grabbers');
            xmltvGrabbers = await response.json();
        } catch (error) {
            console.error('Error loading grabbers:', error);
            return;
        }
    }
    
    select.innerHTML = '<option value="">Select a grabber...</option>';
    for (const grabber of xmltvGrabbers) {
        select.innerHTML += `<option value="${grabber.name}">${grabber.name} - ${grabber.description || 'No description'}</option>`;
    }
}

async function loadXmltvConfigs() {
    const container = document.getElementById('xmltv-configs-list');
    
    try {
        const response = await fetch('/api/xmltv/configs');
        const data = await response.json();
        const configs = data.configs || [];
        
        if (configs.length === 0) {
            container.innerHTML = '<div class="text-center text-muted py-3">No saved configurations</div>';
            return;
        }
        
        let html = '<div class="list-group">';
        for (const config of configs) {
            html += `
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${config.name}</strong>
                        <br><small class="text-muted">Modified: ${new Date(config.modified).toLocaleString()}</small>
                    </div>
                    <button class="btn btn-outline-danger btn-sm" onclick="deleteXmltvConfig('${config.name}')">
                        <i class="bi bi-trash"></i>
                    </button>
                </div>
            `;
        }
        html += '</div>';
        container.innerHTML = html;
        
    } catch (error) {
        container.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    }
}

async function deleteXmltvConfig(configName) {
    if (!confirm(`Delete configuration "${configName}"?`)) return;
    
    try {
        const response = await fetch(`/api/xmltv/configs/${configName}`, { method: 'DELETE' });
        if (response.ok) {
            loadXmltvConfigs();
            alert('✓ Configuration deleted');
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to delete'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

async function testGrabber() {
    const grabberName = document.getElementById('grabberSelect').value;
    const configName = document.getElementById('grabberConfigName').value;
    const resultDiv = document.getElementById('grabberTestResult');
    
    if (!grabberName) {
        alert('Please select a grabber first');
        return;
    }
    
    const btn = document.getElementById('testGrabberBtn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Testing...';
    resultDiv.style.display = 'block';
    resultDiv.innerHTML = '<div class="alert alert-info">Testing grabber, please wait...</div>';
    
    try {
        const response = await fetch(`/api/xmltv/grabbers/${grabberName}/test`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ config_name: configName || null })
        });
        const result = await response.json();
        
        if (result.success) {
            resultDiv.innerHTML = `
                <div class="alert alert-success">
                    <i class="bi bi-check-circle"></i> Test passed!
                    <br>Channels: ${result.channels}, Programs: ${result.programs}
                </div>
            `;
        } else {
            resultDiv.innerHTML = `
                <div class="alert alert-danger">
                    <i class="bi bi-x-circle"></i> Test failed: ${result.message}
                </div>
            `;
        }
    } catch (error) {
        resultDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

async function viewGrabberChannels(grabberName) {
    alert(`Loading channels from ${grabberName}... This may take a moment.`);
    
    try {
        const response = await fetch(`/api/xmltv/grabbers/${grabberName}/channels`);
        const data = await response.json();
        
        if (data.error) {
            alert('Error: ' + data.error);
            return;
        }
        
        const channels = data.channels || [];
        let msg = `Found ${channels.length} channels:\n\n`;
        msg += channels.slice(0, 20).map(c => `${c.id}: ${c.name}`).join('\n');
        if (channels.length > 20) {
            msg += `\n... and ${channels.length - 20} more`;
        }
        alert(msg);
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

function quickCreateGrabberSource(grabberName) {
    // Pre-fill the source modal for this grabber
    document.getElementById('sourceId').value = '';
    document.getElementById('sourceForm').reset();
    document.getElementById('sourceType').value = 'xmltv_grabber';
    document.getElementById('sourceName').value = `XMLTV - ${grabberName}`;
    onSourceTypeChange();
    
    // Set the grabber after the select is populated
    setTimeout(() => {
        document.getElementById('grabberSelect').value = grabberName;
    }, 100);
    
    document.getElementById('sourceModalLabel').textContent = 'Add EPG Source';
    sourceModal.show();
}
</script>
{% endblock %}
