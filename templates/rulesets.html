{% extends "base.html" %}

{% block title %}Tags & Rulesets - IPTV Proxy{% endblock %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pb-2 mb-3 border-bottom">
    <h1 class="h2">Tags & Rulesets</h1>
    <div class="btn-toolbar mb-2 mb-md-0">
        <button class="btn btn-sm btn-danger me-2" id="cleanup-orphan-tags-btn" title="Delete tags with no associated channels">
            <i class="bi bi-trash"></i> Cleanup Orphan Tags
        </button>
        <button class="btn btn-sm btn-primary me-2" id="create-default-ruleset-btn">
            <i class="bi bi-plus-circle"></i> Create Default Ruleset
        </button>
        <button class="btn btn-sm btn-outline-primary" id="create-ruleset-btn">
            <i class="bi bi-plus-circle"></i> New Ruleset
        </button>
    </div>
</div>

<!-- Tabs -->
<ul class="nav nav-tabs mb-4" id="mainTabs" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="rulesets-tab" data-bs-toggle="tab" data-bs-target="#rulesets" type="button">
            <i class="bi bi-collection"></i> Rulesets
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="tags-tab" data-bs-toggle="tab" data-bs-target="#tags" type="button">
            <i class="bi bi-tags"></i> Extracted Tags
        </button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="playlists-tab" data-bs-toggle="tab" data-bs-target="#playlists" type="button">
            <i class="bi bi-music-note-list"></i> Tag Playlists
        </button>
    </li>
</ul>

<div class="tab-content" id="mainTabsContent">
    <!-- Rulesets Tab -->
    <div class="tab-pane fade show active" id="rulesets" role="tabpanel">
        <div id="rulesets-list">
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Tags Tab -->
    <div class="tab-pane fade" id="tags" role="tabpanel">
        <div class="row mb-3">
            <div class="col-md-6">
                <select class="form-select" id="tags-account-filter" onchange="loadTags()">
                    <option value="">All Accounts</option>
                </select>
            </div>
            <div class="col-md-6 text-end">
                <button class="btn btn-sm btn-primary" id="process-all-tags-btn">
                    <i class="bi bi-arrow-repeat"></i> Process All Accounts
                </button>
                <button class="btn btn-sm btn-outline-primary" id="process-account-tags-btn" style="display:none;">
                    <i class="bi bi-arrow-repeat"></i> Process Selected Account
                </button>
            </div>
        </div>
        <div id="tags-list">
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Playlists Tab -->
    <div class="tab-pane fade" id="playlists" role="tabpanel">
        <div class="mb-3">
            <button class="btn btn-sm btn-primary" id="create-playlist-btn">
                <i class="bi bi-plus-circle"></i> New Tag Playlist
            </button>
        </div>
        <div id="playlists-list">
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Create/Edit Ruleset Modal -->
<div class="modal fade" id="rulesetModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="rulesetModalTitle">New Ruleset</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="rulesetForm">
                    <input type="hidden" id="ruleset-id">
                    <div class="mb-3">
                        <label for="ruleset-name" class="form-label">Name *</label>
                        <input type="text" class="form-control" id="ruleset-name" required>
                    </div>
                    <div class="mb-3">
                        <label for="ruleset-description" class="form-label">Description</label>
                        <textarea class="form-control" id="ruleset-description" rows="2"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="ruleset-priority" class="form-label">Priority (lower = higher priority)</label>
                        <input type="number" class="form-control" id="ruleset-priority" value="100">
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="ruleset-enabled" checked>
                        <label class="form-check-label" for="ruleset-enabled">Enabled</label>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="save-ruleset-btn">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Create/Edit Rule Modal -->
<div class="modal fade" id="ruleModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="ruleModalTitle">New Tag Rule</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="ruleForm">
                    <input type="hidden" id="rule-id">
                    <input type="hidden" id="rule-ruleset-id">
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="rule-name" class="form-label">Rule Name *</label>
                            <input type="text" class="form-control" id="rule-name" required>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="rule-tag-name" class="form-label">Tag Name *</label>
                            <input type="text" class="form-control" id="rule-tag-name" required>
                            <small class="form-text text-muted">The tag to apply when matched</small>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="rule-pattern-type" class="form-label">Pattern Type *</label>
                            <select class="form-select" id="rule-pattern-type" required>
                                <option value="prefix">Prefix</option>
                                <option value="suffix">Suffix</option>
                                <option value="contains">Contains</option>
                                <option value="regex">Regex</option>
                            </select>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="rule-source" class="form-label">Source *</label>
                            <select class="form-select" id="rule-source" required>
                                <option value="both">Channel & Category</option>
                                <option value="channel_name">Channel Name Only</option>
                                <option value="category_name">Category Name Only</option>
                            </select>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="rule-pattern" class="form-label">Pattern *</label>
                        <input type="text" class="form-control" id="rule-pattern" required>
                        <small class="form-text text-muted">The pattern to match (e.g., "US|", "HD", "^4K")</small>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="rule-priority" class="form-label">Priority</label>
                            <input type="number" class="form-control" id="rule-priority" value="100">
                            <small class="form-text text-muted">Lower = processed first</small>
                        </div>
                        <div class="col-md-6 mb-3">
                            <div class="form-check mt-4">
                                <input class="form-check-input" type="checkbox" id="rule-remove-from-name" checked>
                                <label class="form-check-label" for="rule-remove-from-name">Remove from name</label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="rule-enabled" checked>
                                <label class="form-check-label" for="rule-enabled">Enabled</label>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="save-rule-btn">Save Rule</button>
            </div>
        </div>
    </div>
</div>

<!-- Assign Ruleset to Account Modal -->
<div class="modal fade" id="assignRulesetModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Assign to Accounts</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="assign-ruleset-id">
                <div id="accounts-assign-list"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Create Tag Playlist Modal -->
<div class="modal fade" id="playlistModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Create Tag Playlist</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="playlistForm">
                    <div class="mb-3">
                        <label for="playlist-account" class="form-label">Account *</label>
                        <select class="form-select" id="playlist-account" required></select>
                    </div>
                    <div class="mb-3">
                        <label for="playlist-name" class="form-label">Playlist Name *</label>
                        <input type="text" class="form-control" id="playlist-name" required>
                    </div>
                    <div class="mb-3">
                        <label for="playlist-required-tags" class="form-label">Required Tags (all must match)</label>
                        <select class="form-select" id="playlist-required-tags" multiple size="6">
                            <option value="">Loading tags...</option>
                        </select>
                        <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple tags. All selected tags must be present on channels.</small>
                    </div>
                    <div class="mb-3">
                        <label for="playlist-excluded-tags" class="form-label">Excluded Tags (none can match)</label>
                        <select class="form-select" id="playlist-excluded-tags" multiple size="6">
                            <option value="">Loading tags...</option>
                        </select>
                        <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple tags. Channels with any of these tags will be excluded.</small>
                    </div>
                    <div id="playlistValidationError" class="alert alert-danger" style="display: none;" role="alert">
                        <i class="bi bi-exclamation-triangle-fill"></i>
                        <span id="playlistValidationMessage"></span>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="save-playlist-btn">Create Playlist</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
let accounts = [];

document.addEventListener('DOMContentLoaded', async () => {
    await loadAccounts();
    await loadRulesets();
    
    // Check for URL parameters (from test page manual tag rule creation)
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('from_test_page') === 'true') {
        // Pre-fill and show the tag rule modal
        await handleManualTagRuleCreation(urlParams);
    }
});

// Tab change handlers
document.getElementById('tags-tab').addEventListener('shown.bs.tab', loadTags);
document.getElementById('playlists-tab').addEventListener('shown.bs.tab', loadPlaylists);

async function loadAccounts() {
    const response = await fetch('/api/accounts');
    accounts = await response.json();
    
    // Populate account filters
    const tagsFilter = document.getElementById('tags-account-filter');
    const playlistAccount = document.getElementById('playlist-account');
    
    accounts.forEach(account => {
        tagsFilter.innerHTML += `<option value="${account.id}">${account.name}</option>`;
        playlistAccount.innerHTML += `<option value="${account.id}">${account.name}</option>`;
    });
}

// ============================================================================
// Rulesets Management
// ============================================================================

async function loadRulesets() {
    try {
        const response = await fetch('/api/rulesets');
        const rulesets = await response.json();
        
        let html = '';
        
        if (rulesets.length === 0) {
            html = `
                <div class="alert alert-info">
                    <h5><i class="bi bi-info-circle"></i> No Rulesets Found</h5>
                    <p>Create a default ruleset to get started with tag extraction.</p>
                </div>
            `;
        } else {
            rulesets.forEach(ruleset => {
                const badge = ruleset.is_default ? '<span class="badge bg-primary ms-2">Default</span>' : '';
                const status = ruleset.enabled ? '<span class="badge bg-success">Enabled</span>' : '<span class="badge bg-secondary">Disabled</span>';
                
                html += `
                    <div class="card mb-3">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">
                                ${ruleset.name} ${badge}
                                <small class="text-muted ms-2">(${ruleset.rule_count} rules, priority: ${ruleset.priority})</small>
                            </h5>
                            <div>
                                ${status}
                                <div class="btn-group ms-2">
                                    <button class="btn btn-sm btn-outline-primary" data-action="show-rules" data-ruleset-id="${ruleset.id}">
                                        <i class="bi bi-list"></i> Rules
                                    </button>
                                    <button class="btn btn-sm btn-outline-info" data-action="show-assign" data-ruleset-id="${ruleset.id}">
                                        <i class="bi bi-link"></i> Assign
                                    </button>
                                    <button class="btn btn-sm btn-outline-secondary" data-action="edit" data-ruleset-id="${ruleset.id}">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger" data-action="delete" data-ruleset-id="${ruleset.id}" ${ruleset.is_default ? 'disabled' : ''}>
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        ${ruleset.description ? `<div class="card-body"><p class="text-muted mb-0">${ruleset.description}</p></div>` : ''}
                        <div class="card-body collapse" id="rules-${ruleset.id}">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6>Tag Extraction Rules</h6>
                                <button class="btn btn-sm btn-success" data-action="create-rule" data-ruleset-id="${ruleset.id}">
                                    <i class="bi bi-plus"></i> Add Rule
                                </button>
                            </div>
                            <div id="rules-list-${ruleset.id}">
                                <div class="text-center py-3">
                                    <div class="spinner-border spinner-border-sm" role="status"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        document.getElementById('rulesets-list').innerHTML = html;
    } catch (error) {
        document.getElementById('rulesets-list').innerHTML = `
            <div class="alert alert-danger">Error loading rulesets: ${error.message}</div>
        `;
    }
}

async function showRulesetRules(rulesetId) {
    const rulesDiv = document.getElementById(`rules-${rulesetId}`);
    new bootstrap.Collapse(rulesDiv, { toggle: true });
    
    if (rulesDiv.classList.contains('show')) {
        return;
    }
    
    try {
        const response = await fetch(`/api/tag-rules?ruleset_id=${rulesetId}`);
        const rules = await response.json();
        
        let html = '';
        if (rules.length === 0) {
            html = '<div class="alert alert-warning">No rules in this ruleset</div>';
        } else {
            html = '<div class="table-responsive"><table class="table table-sm table-hover">';
            html += '<thead><tr><th>Priority</th><th>Name</th><th>Pattern</th><th>Type</th><th>Tag</th><th>Source</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
            
            rules.forEach(rule => {
                const status = rule.enabled ? '<span class="badge bg-success">On</span>' : '<span class="badge bg-secondary">Off</span>';
                const removeIcon = rule.remove_from_name ? '<i class="bi bi-scissors text-warning" title="Removes from name"></i>' : '';
                
                html += `
                    <tr>
                        <td>${rule.priority}</td>
                        <td>${rule.name}</td>
                        <td><code>${rule.pattern}</code></td>
                        <td><span class="badge bg-info">${rule.pattern_type}</span></td>
                        <td><span class="badge bg-primary">${rule.tag_name}</span></td>
                        <td>${rule.source}</td>
                        <td>${status} ${removeIcon}</td>
                        <td>
                            <button class="btn btn-sm btn-outline-secondary" data-action="edit-rule" data-rule-id="${rule.id}">
                                <i class="bi bi-pencil"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger" data-action="delete-rule" data-rule-id="${rule.id}" data-ruleset-id="${rulesetId}">
                                <i class="bi bi-trash"></i>
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
        }
        
        document.getElementById(`rules-list-${rulesetId}`).innerHTML = html;
    } catch (error) {
        document.getElementById(`rules-list-${rulesetId}`).innerHTML = `
            <div class="alert alert-danger">Error loading rules: ${error.message}</div>
        `;
    }
}

function showCreateRulesetModal() {
    document.getElementById('rulesetModalTitle').textContent = 'New Ruleset';
    document.getElementById('rulesetForm').reset();
    document.getElementById('ruleset-id').value = '';
    new bootstrap.Modal(document.getElementById('rulesetModal')).show();
}

async function editRuleset(rulesetId) {
    const response = await fetch(`/api/rulesets/${rulesetId}`);
    const ruleset = await response.json();
    
    document.getElementById('rulesetModalTitle').textContent = 'Edit Ruleset';
    document.getElementById('ruleset-id').value = ruleset.id;
    document.getElementById('ruleset-name').value = ruleset.name;
    document.getElementById('ruleset-description').value = ruleset.description || '';
    document.getElementById('ruleset-priority').value = ruleset.priority;
    document.getElementById('ruleset-enabled').checked = ruleset.enabled;
    
    new bootstrap.Modal(document.getElementById('rulesetModal')).show();
}

async function saveRuleset() {
    const id = document.getElementById('ruleset-id').value;
    const data = {
        name: document.getElementById('ruleset-name').value,
        description: document.getElementById('ruleset-description').value,
        priority: parseInt(document.getElementById('ruleset-priority').value),
        enabled: document.getElementById('ruleset-enabled').checked
    };
    
    try {
        const url = id ? `/api/rulesets/${id}` : '/api/rulesets';
        const method = id ? 'PUT' : 'POST';
        
        const response = await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            bootstrap.Modal.getInstance(document.getElementById('rulesetModal')).hide();
            await loadRulesets();
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to save ruleset'));
        }
    } catch (error) {
        alert('Error saving ruleset: ' + error.message);
    }
}

async function deleteRuleset(rulesetId) {
    if (!confirm('Delete this ruleset and all its rules?')) return;
    
    try {
        const response = await fetch(`/api/rulesets/${rulesetId}`, { method: 'DELETE' });
        if (response.ok) {
            await loadRulesets();
        }
    } catch (error) {
        alert('Error deleting ruleset: ' + error.message);
    }
}

async function createDefaultRuleset() {
    if (!confirm('Create default ruleset with 22 standard tag extraction rules?')) return;
    
    try {
        const response = await fetch('/api/rulesets/create-default', { method: 'POST' });
        const result = await response.json();
        
        if (result.success) {
            alert(result.message);
            await loadRulesets();
        } else {
            alert('Error: ' + result.error);
        }
    } catch (error) {
        alert('Error creating default ruleset: ' + error.message);
    }
}

// ============================================================================
// Rules Management
// ============================================================================

async function handleManualTagRuleCreation(urlParams) {
    const accountId = urlParams.get('account_id');
    const ruleName = urlParams.get('rule_name');
    const pattern = urlParams.get('pattern');
    const patternType = urlParams.get('pattern_type');
    const source = urlParams.get('source');
    const removeFromName = urlParams.get('remove_from_name') === 'true';
    
    // Get or create a ruleset for this account
    const response = await fetch(`/api/accounts/${accountId}/rulesets`);
    const accountRulesets = await response.json();
    
    let rulesetId;
    if (accountRulesets.length > 0) {
        // Use the first ruleset
        rulesetId = accountRulesets[0].id;
    } else {
        // Create a new ruleset for manual tags
        const createResponse = await fetch('/api/rulesets', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                name: `Manual Tags`,
                description: 'Manually created tag rules from channel preview',
                priority: 1000,
                enabled: true
            })
        });
        
        if (!createResponse.ok) {
            alert('Failed to create ruleset for manual tags');
            return;
        }
        
        const newRuleset = await createResponse.json();
        rulesetId = newRuleset.id;
        
        // Assign to account
        await fetch(`/api/accounts/${accountId}/rulesets`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                ruleset_id: rulesetId,
                priority: 1000
            })
        });
        
        await loadRulesets();
    }
    
    // Open the tag rule modal with pre-filled data
    document.getElementById('ruleModalTitle').textContent = 'New Manual Tag Rule';
    document.getElementById('ruleForm').reset();
    document.getElementById('rule-id').value = '';
    document.getElementById('rule-ruleset-id').value = rulesetId;
    document.getElementById('rule-name').value = ruleName;
    document.getElementById('rule-pattern').value = pattern;
    document.getElementById('rule-pattern-type').value = patternType;
    document.getElementById('rule-source').value = source;
    document.getElementById('rule-remove-from-name').checked = removeFromName;
    document.getElementById('rule-priority').value = 1000;
    document.getElementById('rule-enabled').checked = true;
    
    // Focus on tag name field (what user needs to fill in)
    setTimeout(() => {
        document.getElementById('rule-tag-name').focus();
    }, 500);
    
    new bootstrap.Modal(document.getElementById('ruleModal')).show();
    
    // Show info message
    const alertDiv = document.createElement('div');
    alertDiv.className = 'alert alert-info alert-dismissible fade show';
    alertDiv.innerHTML = `
        <strong>Manual Tag Rule:</strong> The pattern has been pre-filled to match this specific channel.
        Just enter the tag name(s) you want to assign and click Save.
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    document.querySelector('.modal-body').insertBefore(alertDiv, document.getElementById('ruleForm'));
}

function showCreateRuleModal(rulesetId) {
    document.getElementById('ruleModalTitle').textContent = 'New Tag Rule';
    document.getElementById('ruleForm').reset();
    document.getElementById('rule-id').value = '';
    document.getElementById('rule-ruleset-id').value = rulesetId;
    new bootstrap.Modal(document.getElementById('ruleModal')).show();
}

async function editRule(ruleId) {
    const response = await fetch(`/api/tag-rules?ruleset_id=`);
    const rules = await response.json();
    const rule = rules.find(r => r.id === ruleId);
    
    if (!rule) return;
    
    document.getElementById('ruleModalTitle').textContent = 'Edit Tag Rule';
    document.getElementById('rule-id').value = rule.id;
    document.getElementById('rule-ruleset-id').value = rule.ruleset_id;
    document.getElementById('rule-name').value = rule.name;
    document.getElementById('rule-tag-name').value = rule.tag_name;
    document.getElementById('rule-pattern-type').value = rule.pattern_type;
    document.getElementById('rule-source').value = rule.source;
    document.getElementById('rule-pattern').value = rule.pattern;
    document.getElementById('rule-priority').value = rule.priority;
    document.getElementById('rule-remove-from-name').checked = rule.remove_from_name;
    document.getElementById('rule-enabled').checked = rule.enabled;
    
    new bootstrap.Modal(document.getElementById('ruleModal')).show();
}

async function saveRule() {
    const id = document.getElementById('rule-id').value;
    const data = {
        ruleset_id: parseInt(document.getElementById('rule-ruleset-id').value),
        name: document.getElementById('rule-name').value,
        tag_name: document.getElementById('rule-tag-name').value,
        pattern_type: document.getElementById('rule-pattern-type').value,
        source: document.getElementById('rule-source').value,
        pattern: document.getElementById('rule-pattern').value,
        priority: parseInt(document.getElementById('rule-priority').value),
        remove_from_name: document.getElementById('rule-remove-from-name').checked,
        enabled: document.getElementById('rule-enabled').checked
    };
    
    try {
        const url = id ? `/api/tag-rules/${id}` : '/api/tag-rules';
        const method = id ? 'PUT' : 'POST';
        
        const response = await fetch(url, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        if (response.ok) {
            bootstrap.Modal.getInstance(document.getElementById('ruleModal')).hide();
            // Reload the specific ruleset's rules
            await showRulesetRules(data.ruleset_id);
            await loadRulesets(); // Refresh rule counts
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Failed to save rule'));
        }
    } catch (error) {
        alert('Error saving rule: ' + error.message);
    }
}

async function deleteRule(ruleId, rulesetId) {
    if (!confirm('Delete this rule?')) return;
    
    try {
        const response = await fetch(`/api/tag-rules/${ruleId}`, { method: 'DELETE' });
        if (response.ok) {
            await showRulesetRules(rulesetId);
            await loadRulesets();
        }
    } catch (error) {
        alert('Error deleting rule: ' + error.message);
    }
}

// ============================================================================
// Ruleset Assignment
// ============================================================================

async function showAssignRuleset(rulesetId) {
    document.getElementById('assign-ruleset-id').value = rulesetId;
    
    let html = '<div class="list-group">';
    
    for (const account of accounts) {
        const response = await fetch(`/api/accounts/${account.id}/rulesets`);
        const accountRulesets = await response.json();
        const isAssigned = accountRulesets.some(r => r.id === rulesetId);
        
        html += `
            <div class="list-group-item d-flex justify-content-between align-items-center">
                <span>${account.name}</span>
                ${isAssigned ? 
                    `<button class="btn btn-sm btn-danger" data-action="unassign" data-account-id="${account.id}" data-ruleset-id="${rulesetId}">
                        <i class="bi bi-x-circle"></i> Unassign
                    </button>` :
                    `<button class="btn btn-sm btn-success" data-action="assign" data-account-id="${account.id}" data-ruleset-id="${rulesetId}">
                        <i class="bi bi-plus-circle"></i> Assign
                    </button>`
                }
            </div>
        `;
    }
    
    html += '</div>';
    document.getElementById('accounts-assign-list').innerHTML = html;
    
    // Only show the modal if it's not already open
    const modalElement = document.getElementById('assignRulesetModal');
    const existingModal = bootstrap.Modal.getInstance(modalElement);
    if (!existingModal || !existingModal._isShown) {
        new bootstrap.Modal(modalElement).show();
    }
}

async function assignRuleset(accountId, rulesetId) {
    try {
        const response = await fetch(`/api/accounts/${accountId}/rulesets`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ruleset_id: rulesetId, priority: 100 })
        });
        
        if (response.ok) {
            await refreshAssignRuleset(rulesetId); // Just refresh content, don't re-show modal
        }
    } catch (error) {
        alert('Error assigning ruleset: ' + error.message);
    }
}

async function unassignRuleset(accountId, rulesetId) {
    try {
        const response = await fetch(`/api/accounts/${accountId}/rulesets/${rulesetId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            await refreshAssignRuleset(rulesetId); // Just refresh content, don't re-show modal
        }
    } catch (error) {
        alert('Error unassigning ruleset: ' + error.message);
    }
}

async function refreshAssignRuleset(rulesetId) {
    // Update modal content without recreating the modal instance
    let html = '<div class="list-group">';
    
    for (const account of accounts) {
        const response = await fetch(`/api/accounts/${account.id}/rulesets`);
        const accountRulesets = await response.json();
        const isAssigned = accountRulesets.some(r => r.id === rulesetId);
        
        html += `
            <div class="list-group-item d-flex justify-content-between align-items-center">
                <span>${account.name}</span>
                ${isAssigned ? 
                    `<button class="btn btn-sm btn-danger" data-action="unassign" data-account-id="${account.id}" data-ruleset-id="${rulesetId}">
                        <i class="bi bi-x-circle"></i> Unassign
                    </button>` :
                    `<button class="btn btn-sm btn-success" data-action="assign" data-account-id="${account.id}" data-ruleset-id="${rulesetId}">
                        <i class="bi bi-plus-circle"></i> Assign
                    </button>`
                }
            </div>
        `;
    }
    
    html += '</div>';
    document.getElementById('accounts-assign-list').innerHTML = html;
}

// ============================================================================
// Tags Display
// ============================================================================

async function loadTags() {
    const accountId = document.getElementById('tags-account-filter').value;
    
    // Show/hide process selected account button
    const processAccountBtn = document.getElementById('process-account-tags-btn');
    if (accountId) {
        processAccountBtn.style.display = 'inline-block';
    } else {
        processAccountBtn.style.display = 'none';
    }
    
    try {
        const url = accountId ? `/api/accounts/${accountId}/tags` : '/api/tags';
        const response = await fetch(url);
        const tags = await response.json();
        
        let html = '';
        if (tags.length === 0) {
            html = '<div class="alert alert-info">No tags extracted yet. Process an account to extract tags.</div>';
        } else {
            html = '<div class="d-flex flex-wrap gap-2">';
            tags.forEach(tag => {
                const count = tag.channel_count || '';
                const clickable = accountId ? 'cursor: pointer;' : 'cursor: default;';
                const title = accountId ? 'Click to preview channels with this tag' : 'Select an account to preview';
                const onClick = accountId ? `onclick="navigateToPreview('${accountId}', '${tag.name.replace(/'/g, "\\'")}')"` : '';
                const previewUrl = accountId ? '#' : '#'; // Use onclick instead
                html += `<a href="${previewUrl}" class="badge bg-primary fs-6 py-2 px-3 text-decoration-none" style="${clickable}" title="${title}" ${onClick}>${tag.name} ${count ? `<span class="badge bg-light text-dark ms-1">${count}</span>` : ''}</a>`;
            });
            html += '</div>';
        }
        
        document.getElementById('tags-list').innerHTML = html;
    } catch (error) {
        document.getElementById('tags-list').innerHTML = `
            <div class="alert alert-danger">Error loading tags: ${error.message}</div>
        `;
    }
}

function navigateToPreview(accountId, tagName) {
    // Navigate to test page with account and tag filters
    window.location.href = `/test?account=${accountId}&tag=${encodeURIComponent(tagName)}`;
}

async function processAccountTags() {
    const accountId = document.getElementById('tags-account-filter').value;
    if (!accountId) return;
    
    const btn = document.getElementById('process-account-tags-btn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Processing...';
    
    try {
        const response = await fetch(`/api/accounts/${accountId}/process-tags`, { method: 'POST' });
        const result = await response.json();
        
        if (result.success) {
            const msg = `Successfully processed ${result.processed} channels\n` +
                       `Unique tags: ${result.unique_tags}\n` +
                       `Tags created: ${result.tags_created}\n` +
                       `Tags updated: ${result.tags_updated}\n` +
                       `Tags removed: ${result.tags_removed}`;
            alert(msg);
            await loadTags();
        } else {
            alert('Error: ' + result.error);
        }
    } catch (error) {
        alert('Error processing tags: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

async function processAllAccountTags() {
    if (!confirm('Process tag extraction for all accounts? This may take a while.')) return;
    
    const btn = document.getElementById('process-all-tags-btn');
    const originalHtml = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span> Processing...';
    
    try {
        let totalProcessed = 0;
        let totalTags = new Set(); // Use set to track unique tags across all accounts
        let accountsProcessed = 0;
        let errors = [];
        
        for (const account of accounts) {
            if (!account.enabled) continue; // Skip disabled accounts
            
            try {
                const response = await fetch(`/api/accounts/${account.id}/process-tags`, { method: 'POST' });
                
                if (!response.ok) {
                    errors.push(`${account.name}: ${response.statusText}`);
                    continue;
                }
                
                const result = await response.json();
                
                if (result.success) {
                    totalProcessed += result.processed || 0;
                    // Add all unique tags to our set
                    if (result.tag_counts) {
                        Object.keys(result.tag_counts).forEach(tag => totalTags.add(tag));
                    }
                    accountsProcessed++;
                }
            } catch (error) {
                console.error(`Error processing account ${account.name}:`, error);
                errors.push(`${account.name}: ${error.message}`);
            }
        }
        
        let message = `Processing complete!\\n`;
        message += `Accounts processed: ${accountsProcessed}\\n`;
        message += `Total channels: ${totalProcessed}\\n`;
        message += `Unique tags extracted: ${totalTags.size}`;
        
        if (errors.length > 0) {
            message += `\\n\\nErrors:\\n` + errors.slice(0, 3).join('\\n');
            if (errors.length > 3) {
                message += `\\n... and ${errors.length - 3} more`;
            }
        }
        
        alert(message);
        await loadTags();
    } catch (error) {
        alert('Error processing tags: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
    }
}

// ============================================================================
// Playlists Management
// ============================================================================

async function loadPlaylists() {
    // This would load saved playlist configurations
    // For now, show a message
    document.getElementById('playlists-list').innerHTML = `
        <div class="alert alert-info">
            <h5><i class="bi bi-info-circle"></i> Tag-Based Playlists</h5>
            <p>Create custom playlists based on extracted tags. You can filter channels by required tags and exclude unwanted tags.</p>
            <p class="mb-0">Click "New Tag Playlist" to get started.</p>
        </div>
    `;
}

function showCreatePlaylistModal() {
    document.getElementById('playlistForm').reset();
    document.getElementById('playlistValidationError').style.display = 'none';
    
    // Load available tags
    loadTagsForPlaylist();
    
    new bootstrap.Modal(document.getElementById('playlistModal')).show();
}

async function loadTagsForPlaylist() {
    try {
        const response = await fetch('/api/tags');
        const tags = await response.json();
        
        const requiredSelect = document.getElementById('playlist-required-tags');
        const excludedSelect = document.getElementById('playlist-excluded-tags');
        
        requiredSelect.innerHTML = '';
        excludedSelect.innerHTML = '';
        
        if (tags.length === 0) {
            requiredSelect.innerHTML = '<option value="">No tags available</option>';
            excludedSelect.innerHTML = '<option value="">No tags available</option>';
        } else {
            for (const tag of tags) {
                requiredSelect.innerHTML += `<option value="${tag.name}">${tag.name}</option>`;
                excludedSelect.innerHTML += `<option value="${tag.name}">${tag.name}</option>`;
            }
        }
    } catch (error) {
        console.error('Error loading tags:', error);
        document.getElementById('playlist-required-tags').innerHTML = '<option value="">Error loading tags</option>';
        document.getElementById('playlist-excluded-tags').innerHTML = '<option value="">Error loading tags</option>';
    }
}

async function savePlaylist() {
    const accountId = document.getElementById('playlist-account').value;
    const name = document.getElementById('playlist-name').value.trim();
    
    // Get selected tags from multi-select
    const requiredSelect = document.getElementById('playlist-required-tags');
    const excludedSelect = document.getElementById('playlist-excluded-tags');
    const requiredTags = Array.from(requiredSelect.selectedOptions).map(opt => opt.value);
    const excludedTags = Array.from(excludedSelect.selectedOptions).map(opt => opt.value);
    
    const errorDiv = document.getElementById('playlistValidationError');
    const errorMsg = document.getElementById('playlistValidationMessage');
    
    // Client-side validation
    if (!accountId) {
        errorDiv.style.display = 'block';
        errorMsg.textContent = 'Please select an account.';
        document.getElementById('playlist-account').classList.add('is-invalid');
        return;
    }
    
    if (!name) {
        errorDiv.style.display = 'block';
        errorMsg.textContent = 'Please enter a playlist name.';
        document.getElementById('playlist-name').classList.add('is-invalid');
        return;
    }
    
    // Clear validation styles
    errorDiv.style.display = 'none';
    document.getElementById('playlist-account').classList.remove('is-invalid');
    document.getElementById('playlist-name').classList.remove('is-invalid');
    
    const data = {
        account_id: parseInt(accountId),
        name: name,
        required_tags: requiredTags,
        excluded_tags: excludedTags
    };
    
    try {
        const response = await fetch('/api/playlist-configs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
        
        const result = await response.json();
        
        if (response.ok) {
            bootstrap.Modal.getInstance(document.getElementById('playlistModal')).hide();
            
            // Show the generated URL
            alert(`Playlist created!\\n\\nURL: ${window.location.origin}/playlist/config/${result.id}.m3u`);
            await loadPlaylists();
        } else {
            // Show validation error in modal
            errorDiv.style.display = 'block';
            errorDiv.className = 'alert alert-danger border border-danger';
            
            // Extract detailed error message
            let errorMessage = 'Validation failed';
            if (result.error) {
                errorMessage = result.error;
            } else if (result.errors) {
                // Handle marshmallow validation errors
                const errorList = Object.entries(result.errors)
                    .map(([field, messages]) => `${field}: ${Array.isArray(messages) ? messages.join(', ') : messages}`)
                    .join('; ');
                errorMessage = errorList;
            }
            
            errorMsg.textContent = errorMessage;
            
            // Highlight invalid fields if possible
            if (result.errors) {
                Object.keys(result.errors).forEach(field => {
                    const input = document.getElementById(`playlist-${field.replace('_', '-')}`);
                    if (input) input.classList.add('is-invalid');
                });
            }
        }
    } catch (error) {
        errorDiv.style.display = 'block';
        errorDiv.className = 'alert alert-danger border border-danger';
        errorMsg.textContent = 'Error creating playlist: ' + error.message;
    }
}

// Initialize event listeners after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Static button listeners
    const cleanupOrphanTagsBtn = document.getElementById('cleanup-orphan-tags-btn');
    if (cleanupOrphanTagsBtn) {
        cleanupOrphanTagsBtn.addEventListener('click', async () => {
            if (!confirm('Delete all tags that have no associated channels? This cannot be undone.')) return;
            
            try {
                cleanupOrphanTagsBtn.disabled = true;
                cleanupOrphanTagsBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Cleaning...';
                
                const response = await fetch('/api/tags/cleanup-orphans', { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    alert(`Cleanup complete!\n\n${result.tags_deleted} orphaned tags deleted.\n\nSample tags removed:\n${result.sample_tags.slice(0, 10).join(', ')}`);
                    // Reload tags if on tags tab
                    if (document.getElementById('tags').classList.contains('active')) {
                        loadTags();
                    }
                } else {
                    alert('Error cleaning up tags: ' + (result.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            } finally {
                cleanupOrphanTagsBtn.disabled = false;
                cleanupOrphanTagsBtn.innerHTML = '<i class="bi bi-trash"></i> Cleanup Orphan Tags';
            }
        });
    }

    const createDefaultBtn = document.getElementById('create-default-ruleset-btn');
    if (createDefaultBtn) {
        createDefaultBtn.addEventListener('click', () => createDefaultRuleset());
    }

    const createRulesetBtn = document.getElementById('create-ruleset-btn');
    if (createRulesetBtn) {
        createRulesetBtn.addEventListener('click', () => showCreateRulesetModal());
    }

    const processAllTagsBtn = document.getElementById('process-all-tags-btn');
    if (processAllTagsBtn) {
        processAllTagsBtn.addEventListener('click', () => processAllAccountTags());
    }

    const processAccountTagsBtn = document.getElementById('process-account-tags-btn');
    if (processAccountTagsBtn) {
        processAccountTagsBtn.addEventListener('click', () => processAccountTags());
    }

    const createPlaylistBtn = document.getElementById('create-playlist-btn');
    if (createPlaylistBtn) {
        createPlaylistBtn.addEventListener('click', () => showCreatePlaylistModal());
    }

    const saveRulesetBtn = document.getElementById('save-ruleset-btn');
    if (saveRulesetBtn) {
        saveRulesetBtn.addEventListener('click', () => saveRuleset());
    }

    const saveRuleBtn = document.getElementById('save-rule-btn');
    if (saveRuleBtn) {
        saveRuleBtn.addEventListener('click', () => saveRule());
    }

    const savePlaylistBtn = document.getElementById('save-playlist-btn');
    if (savePlaylistBtn) {
        savePlaylistBtn.addEventListener('click', () => savePlaylist());
    }

    // Event delegation for ruleset operations
    const rulesetsContainer = document.getElementById('rulesets-list');
    if (rulesetsContainer) {
        rulesetsContainer.addEventListener('click', async (e) => {
            const button = e.target.closest('button[data-action]');
            if (!button) return;

            const action = button.dataset.action;
            const rulesetId = parseInt(button.dataset.rulesetId);
            const ruleId = parseInt(button.dataset.ruleId);

            switch (action) {
                case 'show-rules':
                    await showRulesetRules(rulesetId);
                    break;
                case 'show-assign':
                    await showAssignRuleset(rulesetId);
                    break;
                case 'edit':
                    await editRuleset(rulesetId);
                    break;
                case 'delete':
                    await deleteRuleset(rulesetId);
                    break;
                case 'create-rule':
                    showCreateRuleModal(rulesetId);
                    break;
                case 'edit-rule':
                    await editRule(ruleId);
                    break;
                case 'delete-rule':
                    const rulesetIdForDel = parseInt(button.dataset.rulesetId);
                    await deleteRule(ruleId, rulesetIdForDel);
                    break;
            }
        });
    }

    // Event delegation for assign/unassign operations
    const accountsAssignList = document.getElementById('accounts-assign-list');
    if (accountsAssignList) {
        accountsAssignList.addEventListener('click', async (e) => {
            const button = e.target.closest('button[data-action]');
            if (!button) return;

            const action = button.dataset.action;
            const accountId = parseInt(button.dataset.accountId);
            const rulesetId = parseInt(button.dataset.rulesetId);

            if (action === 'assign') {
                await assignRuleset(accountId, rulesetId);
            } else if (action === 'unassign') {
                await unassignRuleset(accountId, rulesetId);
            }
        });
    }
});
</script>
{% endblock %}
