{% extends "base.html" %}

{% block title %}Preview Channels - IPTV Proxy{% endblock %}

{% block extra_css %}
<style>
#tagDropdown {
    border: 1px solid #dee2e6;
    border-radius: 0.25rem;
    background: white;
}
#tagDropdown .list-group-item {
    border: none;
    border-bottom: 1px solid #f0f0f0;
}
#tagDropdown .list-group-item:last-child {
    border-bottom: none;
}
#tagDropdown .list-group-item:hover {
    background-color: #f8f9fa;
}
#selectedTags .badge {
    padding: 0.5rem 0.75rem;
}
#selectedTags .btn-close {
    padding: 0;
    margin: 0;
    width: 0.6rem;
    height: 0.6rem;
}
</style>
{% endblock %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pb-2 mb-3 border-bottom">
    <h1 class="h2">Preview Channels</h1>
</div>

<div class="row">
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h5>Select Account</h5>
            </div>
            <div class="card-body">
                <select class="form-select mb-3" id="testAccountId">
                    <option value="">Select an account...</option>
                </select>
                
                <div class="mb-3">
                    <label for="tagSearchInput" class="form-label">Filter by Tags</label>
                    <div class="position-relative">
                        <input 
                            type="text" 
                            class="form-control" 
                            id="tagSearchInput" 
                            placeholder="Search tags..." 
                            autocomplete="off"
                        >
                        <div id="tagDropdown" class="list-group position-absolute w-100 shadow-sm" style="max-height: 200px; overflow-y: auto; z-index: 1000; display: none;"></div>
                    </div>
                    <div id="selectedTags" class="mt-2"></div>
                    <div class="form-text">Type to search and click to add tags. Channels must have at least one selected tag.</div>
                </div>
                
                <div class="d-grid gap-2">
                    <button class="btn btn-primary" id="load-preview-btn">
                        <i class="bi bi-eye"></i> Preview Channels
                    </button>
                    <button class="btn btn-success" id="download-playlist-btn">
                        <i class="bi bi-download"></i> Download M3U
                    </button>
                </div>
            </div>
        </div>
        
        <div class="card mt-3">
            <div class="card-header">
                <h5>Active Filters</h5>
            </div>
            <div class="card-body" id="activeFilters">
                <p class="text-muted">Select an account to view filters</p>
            </div>
        </div>
    </div>
    
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h5>Channel Preview</h5>
            </div>
            <div class="card-body">
                <div id="previewResult">
                    <p class="text-muted">Select an account and click "Preview Channels"</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let accounts = [];
let currentAccountId = null;
let totalChannels = 0;
let loadedChannels = 0;
const CHANNELS_PER_PAGE = 50;
let loadingMore = false;
let hasMore = true;
let selectedTags = [];
let searchTimeout = null;

async function loadAccounts() {
    const response = await fetch('/api/accounts');
    accounts = await response.json();
    
    const select = document.getElementById('testAccountId');
    select.innerHTML = '<option value="">Select an account...</option>';
    
    for (const account of accounts) {
        if (account.enabled) {
            select.innerHTML += `<option value="${account.id}">${account.name}</option>`;
        }
    }
    
    // Check URL params
    const params = new URLSearchParams(window.location.search);
    const accountId = params.get('account');
    const tagName = params.get('tag');
    
    if (accountId) {
        select.value = accountId;
        
        // If a tag is specified, load it first then preview
        if (tagName) {
            await loadTagFromUrl(accountId, tagName);
        } else {
            await loadPreview();
        }
    }
}

async function loadTagFromUrl(accountId, tagName) {
    try {
        // Fetch the specific tag to get its details
        const response = await fetch(`/api/accounts/${accountId}/tags/search?q=${encodeURIComponent(tagName)}&limit=1`);
        const tags = await response.json();
        
        if (tags.length > 0 && tags[0].name === tagName) {
            selectedTags.push(tags[0]);
            renderSelectedTags();
        }
        
        // Load preview with the tag filter
        await loadPreview();
    } catch (error) {
        console.error('Error loading tag from URL:', error);
        // Still try to load preview
        await loadPreview();
    }
}

function clearSelectedTags() {
    selectedTags = [];
    renderSelectedTags();
}

function searchTags() {
    const accountId = document.getElementById('testAccountId').value;
    if (!accountId) return;
    
    const query = document.getElementById('tagSearchInput').value.trim();
    
    // Debounce search
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(async () => {
        try {
            const response = await fetch(`/api/accounts/${accountId}/tags/search?q=${encodeURIComponent(query)}&limit=20`);
            const tags = await response.json();
            
            const dropdown = document.getElementById('tagDropdown');
            dropdown.innerHTML = '';
            
            if (tags.length === 0) {
                dropdown.innerHTML = '<div class="list-group-item text-muted">No tags found</div>';
            } else {
                for (const tag of tags) {
                    // Skip already selected tags
                    if (selectedTags.some(t => t.name === tag.name)) continue;
                    
                    const item = document.createElement('a');
                    item.href = '#';
                    item.className = 'list-group-item list-group-item-action';
                    item.innerHTML = `${tag.name} <span class="badge bg-secondary">${tag.channel_count}</span>`;
                    item.onclick = (e) => {
                        e.preventDefault();
                        addTag(tag);
                    };
                    dropdown.appendChild(item);
                }
            }
            
            dropdown.style.display = 'block';
        } catch (error) {
            console.error('Error searching tags:', error);
        }
    }, 300);
}

function showTagDropdown() {
    const accountId = document.getElementById('testAccountId').value;
    if (accountId) {
        searchTags();
    }
}

function hideTagDropdown() {
    setTimeout(() => {
        document.getElementById('tagDropdown').style.display = 'none';
    }, 200);
}

function addTag(tag) {
    if (!selectedTags.some(t => t.name === tag.name)) {
        selectedTags.push(tag);
        renderSelectedTags();
        document.getElementById('tagSearchInput').value = '';
        document.getElementById('tagDropdown').innerHTML = '';
        document.getElementById('tagDropdown').style.display = 'none';
    }
}

function removeTag(tagName) {
    selectedTags = selectedTags.filter(t => t.name !== tagName);
    renderSelectedTags();
}

function renderSelectedTags() {
    const container = document.getElementById('selectedTags');
    if (selectedTags.length === 0) {
        container.innerHTML = '';
        return;
    }
    
    container.innerHTML = selectedTags.map(tag => `
        <span class="badge bg-primary me-1 mb-1" style="font-size: 0.9rem;">
            ${tag.name} (${tag.channel_count})
            <button type="button" class="btn-close btn-close-white ms-1" style="font-size: 0.6rem;" data-action="remove-tag" data-tag-name="${tag.name}" aria-label="Remove"></button>
        </span>
    `).join('');
}

// Hide dropdown when clicking outside
document.addEventListener('click', function(e) {
    const tagInput = document.getElementById('tagSearchInput');
    const tagDropdown = document.getElementById('tagDropdown');
    if (e.target !== tagInput && !tagDropdown.contains(e.target)) {
        hideTagDropdown();
    }
});

async function loadPreview() {
    const accountId = document.getElementById('testAccountId').value;
    if (!accountId) return;
    
    // Reset state
    currentAccountId = accountId;
    totalChannels = 0;
    loadedChannels = 0;
    hasMore = true;
    
    document.getElementById('previewResult').innerHTML = `
        <div class="text-center">
            <div class="spinner-border" role="status"></div>
            <p>Loading channels...</p>
        </div>
    `;
    
    // Load filters
    try {
        const filtersResponse = await fetch(`/api/accounts/${accountId}/filters`);
        const filters = await filtersResponse.json();
        
        let filtersHtml = '';
        if (filters.length === 0) {
            filtersHtml = '<p class="text-muted">No filters configured</p>';
        } else {
            filtersHtml = '<ul class="list-group list-group-flush">';
            for (const filter of filters.filter(f => f.enabled)) {
                const badge = filter.filter_action === 'whitelist' ? 'success' : 'danger';
                filtersHtml += `
                    <li class="list-group-item">
                        <span class="badge bg-${badge}">${filter.filter_action}</span>
                        <strong>${filter.filter_type}:</strong> ${filter.filter_value}
                    </li>
                `;
            }
            filtersHtml += '</ul>';
        }
        document.getElementById('activeFilters').innerHTML = filtersHtml;
    } catch (error) {
        document.getElementById('activeFilters').innerHTML = `<p class="text-danger">Error loading filters</p>`;
    }
    
    // Initialize display
    const html = `
        <div class="alert alert-info" id="channelCount">
            Loading channels...
        </div>
        <div class="table-responsive">
            <table class="table table-sm table-hover">
                <thead>
                    <tr>
                        <th>Icon</th>
                        <th>Channel Name</th>
                        <th>Cleaned Name</th>
                        <th>Category</th>
                        <th>Tags</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="channelsTableBody">
                </tbody>
            </table>
        </div>
        <div id="loadingIndicator" class="text-center my-3" style="min-height: 50px;">
            <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Loading more...</span>
            </div>
            Loading more channels...
        </div>
    `;
    
    document.getElementById('previewResult').innerHTML = html;
    
    // Set up intersection observer
    setupInfiniteScroll();
    
    // Load first batch
    await loadMoreChannels();
}

async function loadMoreChannels() {
    if (loadingMore || !hasMore || !currentAccountId) return;
    
    loadingMore = true;
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (loadingIndicator) loadingIndicator.style.display = 'block';
    
    try {
        // Get selected tags from our new tag selector
        const tagParam = selectedTags.length > 0 ? `&tags=${selectedTags.map(t => t.name).join(',')}` : '';
        
        const response = await fetch(`/api/accounts/${currentAccountId}/preview?limit=${CHANNELS_PER_PAGE}&offset=${loadedChannels}${tagParam}`);
        const data = await response.json();
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Update total on first load
        if (data.total > 0) {
            totalChannels = data.total;
        }
        
        // Show data source indicator on first load
        if (loadedChannels === 0) {
            const dataSourceBadge = data.using_database 
                ? '<span class="badge bg-success ms-2" title="Using local database"><i class="bi bi-database-check"></i> Database</span>'
                : '<span class="badge bg-warning text-dark ms-2" title="Using IPTV API"><i class="bi bi-cloud"></i> API</span>';
            
            const countDisplay = document.getElementById('channelCount');
            if (countDisplay) {
                countDisplay.innerHTML += dataSourceBadge;
            }
        }
        
        // Append channels to table
        const tbody = document.getElementById('channelsTableBody');
        let html = '';
        
        for (const channel of data.channels) {
            const tagsHtml = channel.tags && channel.tags.length > 0 
                ? channel.tags.map(tag => `<span class="badge bg-info me-1">${tag}</span>`).join('')
                : '<span class="text-muted">No tags</span>';
            
            // Show cleaned name if different from original
            const cleanedNameHtml = channel.cleaned_name && channel.cleaned_name !== channel.name
                ? `<div class="text-muted small">${channel.cleaned_name}</div>`
                : '';
            
            html += `
                <tr>
                    <td>${channel.icon ? `<img src="${channel.icon}" width="40" height="30" onerror="this.style.display='none'">` : ''}</td>
                    <td>
                        ${channel.name}
                        ${cleanedNameHtml}
                    </td>
                    <td>${channel.cleaned_name || '<span class="text-muted">-</span>'}</td>
                    <td><span class="badge bg-secondary">${channel.category}</span></td>
                    <td>${tagsHtml}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary" data-action="create-tag-rule" data-channel-name="${escapeHtml(channel.name)}" data-channel-id="${channel.id}" title="Create tag rule for this channel">
                            <i class="bi bi-tag"></i>
                        </button>
                    </td>
                </tr>
            `;
        }
        
        if (tbody) tbody.innerHTML += html;
        
        // Update state
        loadedChannels += data.showing;
        hasMore = data.has_more;
        
        // Update count display
        const countDisplay = document.getElementById('channelCount');
        if (countDisplay) {
            if (totalChannels > 0) {
                countDisplay.innerHTML = `Showing ${loadedChannels.toLocaleString()} of ${totalChannels.toLocaleString()} channels`;
            } else {
                countDisplay.innerHTML = `Loaded ${loadedChannels.toLocaleString()} channels`;
            }
        }
        
        // Hide loading indicator if no more channels
        if (!hasMore && loadingIndicator) {
            loadingIndicator.style.display = 'none';
        }
        
    } catch (error) {
        document.getElementById('previewResult').innerHTML = `
            <div class="alert alert-danger">
                Error loading channels: ${error.message}
            </div>
        `;
    }
    
    loadingMore = false;
}

function setupInfiniteScroll() {
    const loadingIndicator = document.getElementById('loadingIndicator');
    if (!loadingIndicator) return;
    
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && !loadingMore && hasMore) {
                loadMoreChannels();
            }
        });
    }, {
        root: null,
        rootMargin: '200px',
        threshold: 0.1
    });
    
    observer.observe(loadingIndicator);
}

function downloadPlaylist() {
    const accountId = document.getElementById('testAccountId').value;
    if (!accountId) {
        alert('Please select an account first');
        return;
    }
    
    window.open(`/playlist/${accountId}.m3u`, '_blank');
}

function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}

function createManualTagRule(channelName) {
    const accountId = document.getElementById('testAccountId').value;
    if (!accountId) {
        alert('Please select an account first');
        return;
    }
    
    // Create a regex pattern that matches this exact channel name
    // Escape special regex characters
    const escapedName = channelName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const pattern = `^${escapedName}$`;
    
    // Create URL parameters for pre-filling the tag rule form
    const params = new URLSearchParams({
        account_id: accountId,
        rule_name: `Manual tag for ${channelName}`,
        pattern: pattern,
        pattern_type: 'regex',
        source: 'channel_name',
        remove_from_name: 'false',
        from_test_page: 'true'
    });
    
    // Open rulesets page in new tab with pre-filled parameters
    window.open(`/rulesets?${params.toString()}`, '_blank');
}

loadAccounts();

// Initialize event listeners after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Load Preview button
    const loadPreviewBtn = document.getElementById('load-preview-btn');
    if (loadPreviewBtn) {
        loadPreviewBtn.addEventListener('click', () => loadPreview());
    }

    // Download Playlist button
    const downloadBtn = document.getElementById('download-playlist-btn');
    if (downloadBtn) {
        downloadBtn.addEventListener('click', () => downloadPlaylist());
    }

    // Event delegation for tag operations
    const selectedTagsDiv = document.getElementById('selected-tags');
    if (selectedTagsDiv) {
        selectedTagsDiv.addEventListener('click', (e) => {
            const button = e.target.closest('button[data-action="remove-tag"]');
            if (button) {
                const tagName = button.dataset.tagName;
                removeTag(tagName);
            }
        });
    }

    // Event delegation for channel operations
    const channelsPreview = document.getElementById('channels-preview');
    if (channelsPreview) {
        channelsPreview.addEventListener('click', (e) => {
            const button = e.target.closest('button[data-action="create-tag-rule"]');
            if (button) {
                const channelName = button.dataset.channelName;
                createManualTagRule(channelName);
            }
        });
    }

    // Account selector change
    const testAccountSelect = document.getElementById('testAccountId');
    if (testAccountSelect) {
        testAccountSelect.addEventListener('change', () => clearSelectedTags());
    }

    // Tag search input
    const tagSearchInput = document.getElementById('tagSearchInput');
    if (tagSearchInput) {
        tagSearchInput.addEventListener('input', () => searchTags());
        tagSearchInput.addEventListener('focus', () => showTagDropdown());
    }
});
</script>
{% endblock %}
